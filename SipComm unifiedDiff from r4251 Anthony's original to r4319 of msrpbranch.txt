Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/service/protocol/FileTransferException.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/service/protocol/FileTransferException.java	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/service/protocol/FileTransferException.java	(revision 4319)
@@ -6,6 +6,8 @@
  */
 package net.java.sip.communicator.service.protocol;
 
+import java.text.ParseException;
+
 /**
  * FileTransferException indicates an exception that occurred in the during a
  * file transfer.
@@ -18,6 +20,34 @@
 public class FileTransferException
 	extends Exception
 {
+    /**
+     * 
+     */
+    public FileTransferException()
+    {
+        super();
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     * @param arg1
+     */
+    public FileTransferException(String arg0, Throwable arg1)
+    {
+        super(arg0, arg1);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     */
+    public FileTransferException(Throwable arg0)
+    {
+        super(arg0);
+        // TODO Auto-generated constructor stub
+    }
+
     //TODO: add an error code system
     /**
      * Creates an exception with the specified error message.
@@ -28,4 +58,9 @@
     {
         super(message);
     }
+
+    public FileTransferException(Exception e)
+    {
+        super(e);
+    }
 }
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/service/protocol/FileTransferSC.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/service/protocol/FileTransferSC.java	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/service/protocol/FileTransferSC.java	(revision 4319)
@@ -24,7 +24,7 @@
      * Returns a File that represents the file that is being 
      * transfered .
      * 
-     * @return a File that represents the file
+     * @return a String that represents the file
      */
     public String getFileName();
 
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/version/NightlyBuildID.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/version/NightlyBuildID.java	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/version/NightlyBuildID.java	(revision 4319)
@@ -13,5 +13,5 @@
  */
 public class NightlyBuildID
 {
-    public static final String BUILD_ID="0.build.by.EJekT4";
+    public static final String BUILD_ID="0.build.by.POSTO-2";
 }
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/OperationSetBasicTelephonySipImpl.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/OperationSetBasicTelephonySipImpl.java	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/OperationSetBasicTelephonySipImpl.java	(revision 4319)
@@ -9,6 +9,9 @@
 import java.net.*;
 import java.text.*;
 import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 import javax.sip.*;
 import javax.sip.address.*;
 import javax.sip.header.*;
@@ -72,10 +75,11 @@
 
         this.protocolProvider = protocolProvider;
 
-        protocolProvider.registerMethodProcessor(Request.INVITE, this);
+        //FIXME uncomment those:
+        /*protocolProvider.registerMethodProcessor(Request.INVITE, this);
         protocolProvider.registerMethodProcessor(Request.CANCEL, this);
         protocolProvider.registerMethodProcessor(Request.ACK, this);
-        protocolProvider.registerMethodProcessor(Request.BYE, this);
+        protocolProvider.registerMethodProcessor(Request.BYE, this);*/
     }
 
     /**
@@ -397,10 +401,35 @@
      */
     public void processRequest(RequestEvent requestEvent)
     {
+        //if this request has a SDP with a file selector that means
+        //that this request isn't for us, just exit silently
+        Request request = requestEvent.getRequest();
+        ContentLengthHeader cl = request.getContentLength();
+        String sdpDescription;
+        if (cl != null && cl.getContentLength() > 0)
+        {
+            sdpDescription = new String(request.getRawContent());
+         // let's look at the SDP in order to assert if this invite is for us.
+            // Seen that a file transfer must have an attribute file-selector
+            // present we'll use that to identify if this is meant for us or
+            // not
+            Pattern fileSelectorPattern =
+                Pattern.compile("(.*)\r\n(a=file-selector:)(.*)", Pattern.DOTALL);
+            Matcher fileSelectorMatcher =
+                fileSelectorPattern.matcher(sdpDescription);
+
+            if (fileSelectorMatcher.matches())
+            {
+                logger.trace("Received an invite with an SDP that is not "
+                    + "meant for this function. SDP content: " + sdpDescription);
+                return;
+            }
+        }
+        
+        
         ServerTransaction serverTransaction = requestEvent
             .getServerTransaction();
         SipProvider jainSipProvider = (SipProvider)requestEvent.getSource();
-        Request request = requestEvent.getRequest();
 
         if (serverTransaction == null)
         {
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/FileTransferIllegalSdpException.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/FileTransferIllegalSdpException.java	(revision 0)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/FileTransferIllegalSdpException.java	(revision 4319)
@@ -0,0 +1,50 @@
+/**
+ * 
+ */
+package net.java.sip.communicator.impl.protocol.sip;
+
+/**
+ * @author João André Pereira Antunes
+ *
+ */
+public class FileTransferIllegalSdpException
+    extends Exception
+{
+
+    /**
+     * 
+     */
+    public FileTransferIllegalSdpException()
+    {
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     */
+    public FileTransferIllegalSdpException(String arg0)
+    {
+        super(arg0);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     */
+    public FileTransferIllegalSdpException(Throwable arg0)
+    {
+        super(arg0);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * @param arg0
+     * @param arg1
+     */
+    public FileTransferIllegalSdpException(String arg0, Throwable arg1)
+    {
+        super(arg0, arg1);
+        // TODO Auto-generated constructor stub
+    }
+
+}
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/sip.provider.manifest.mf
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/sip.provider.manifest.mf	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/sip.provider.manifest.mf	(revision 4319)
@@ -19,4 +19,6 @@
  javax.xml.transform,
  javax.xml.transform.dom,
  javax.xml.transform.stream,
+ javax.sdp,
+ msrp,
  org.apache.log4j
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/OperationSetFileTransferSipImpl.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/OperationSetFileTransferSipImpl.java	(revision 0)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/OperationSetFileTransferSipImpl.java	(revision 4319)
@@ -0,0 +1,1771 @@
+/**
+ * 
+ */
+package net.java.sip.communicator.impl.protocol.sip;
+
+import msrp.*;
+import msrp.Message;
+import msrp.Transaction;
+
+import java.io.*;
+import java.util.*;
+import java.util.regex.Pattern;
+import java.net.*;
+import java.text.*;
+import java.util.regex.*;
+
+import javax.sdp.*;
+import javax.sdp.Connection;
+import javax.sip.*;
+import javax.sip.header.*;
+import javax.sip.message.*;
+import javax.sip.address.*;
+
+import net.java.sip.communicator.util.*;
+
+import net.java.sip.communicator.service.media.CallSession;
+import net.java.sip.communicator.service.media.MediaException;
+import net.java.sip.communicator.service.protocol.*;
+import net.java.sip.communicator.service.protocol.event.*;
+
+/**
+ * Implements all of the needed methods in order to add file transfer
+ * functionality to the SIP protocol
+ * 
+ * complies with draft-ietf-mmusic-file-transfer-mech-08 IETF draft (minus some
+ * little things see TODO and FIXME comments)
+ * 
+ * only implements the Offerer is a file sender and Answerer is a file receiver
+ * 
+ * @author João André Pereira Antunes
+ * 
+ */
+public class OperationSetFileTransferSipImpl implements
+		OperationSetFileTransfer, SipListener {
+
+	private static final Logger logger = Logger
+			.getLogger(OperationSetFileTransferSipImpl.class);
+
+	/**
+	 * Field that is a counter for the Origin (o=) field of the SDP
+	 */
+	private static Long sessionID = new Long(1);
+
+	/**
+	 * random number generator used for the file-transfer-id attribute on the
+	 * SDP of new sent files
+	 * 
+	 * TODO this could be done in another way, see comments in sendFile()
+	 */
+	private Random random = new Random();
+
+	/**
+	 * A reference to the <tt>ProtocolProviderServiceSipImpl</tt> instance that
+	 * created us.
+	 */
+	private ProtocolProviderServiceSipImpl protocolProvider = null;
+
+	/**
+	 * A list of listeners registered for file transfer events.
+	 */
+	private Vector fileTransferListeners = new Vector();
+
+	/*
+	 * FIXME (?!) not entirely sure the next field applies to this context but
+	 * it can't hurt :)
+	 */
+	/**
+	 * The name of the boolean property that the user could use to specify
+	 * whether incoming calls should be rejected if the user name in the
+	 * destination (to) address does not match the one that we have in our sip
+	 * address.
+	 */
+	private static final String FAIL_CALLS_ON_DEST_USER_MISMATCH = "net.java.sip.communicator.impl.protocol.sip."
+			+ "FAIL_CALLS_ON_DEST_USER_MISMATCH";
+
+	/**
+	 * Contains references for all currently active (non ended) file transfers.
+	 */
+	private ActiveFileTransferRepository activeFileTransferRepository = new ActiveFileTransferRepository(
+			this);
+
+	/**
+	 * Creates a new instance and adds itself as an <tt>INVITE</tt> method
+	 * handler in the creating protocolProvider.
+	 * 
+	 * @param protocolProvider
+	 *            a reference to the <tt>ProtocolProviderServiceSipImpl</tt>
+	 *            instance that created us.
+	 * 
+	 *            TODO make this compatible with
+	 *            OperationSetBasicTelephonySipImpl registration
+	 * 
+	 */
+	public OperationSetFileTransferSipImpl(
+			ProtocolProviderServiceSipImpl protocolProvider) {
+
+		this.protocolProvider = protocolProvider;
+		protocolProvider.registerMethodProcessor(Request.INVITE, this);
+		protocolProvider.registerMethodProcessor(Request.CANCEL, this);
+		protocolProvider.registerMethodProcessor(Request.ACK, this);
+		protocolProvider.registerMethodProcessor(Request.BYE, this);
+	}
+
+	/**
+	 * Registers a FileTransfListener with this operation set so that the
+	 * registered listener gets notified of events ocurred
+	 * 
+	 * @param listener
+	 *            the <tt>FileTransfListener</tt> to register.
+	 */
+	@Override
+	public void addFileTransfListeners(FileTransfListener listener) {
+		synchronized (fileTransferListeners) {
+			if (!fileTransferListeners.contains(listener)) {
+				this.fileTransferListeners.add(listener);
+			}
+		}
+	}
+
+	/**
+	 * Unregisters <tt>listener</tt> so that it won't receive any further
+	 * notifications upon any of the events generated
+	 * 
+	 * @param listener
+	 *            the <tt>FileTransfListener</tt> to unregister.
+	 */
+	@Override
+	public void removeFileTransfListeners(FileTransfListener listener) {
+		synchronized (fileTransferListeners) {
+			this.fileTransferListeners.remove(listener);
+		}
+	}
+
+	/**
+	 * Parses the the <tt>uriStr</tt> string and returns a JAIN SIP URI.
+	 * 
+	 * @param uriStr
+	 *            a <tt>String</tt> containing the uri to parse.
+	 * 
+	 * @return a URI object corresponding to the <tt>uriStr</tt> string.
+	 * @throws ParseException
+	 *             if uriStr is not properly formatted.
+	 * 
+	 * @author Emil Ivov
+	 */
+	private Address parseAddressStr(String uriStr) throws ParseException {
+		uriStr = uriStr.trim();
+
+		// Handle default domain name (i.e. transform 1234 -> 1234@sip.com)
+		// assuming that if no domain name is specified then it should be the
+		// same as ours.
+		if (uriStr.indexOf('@') == -1 && !uriStr.trim().startsWith("tel:")) {
+			uriStr = uriStr
+					+ "@"
+					+ ((SipURI) protocolProvider.getOurSipAddress().getURI())
+							.getHost();
+		}
+
+		// Let's be uri fault tolerant and add the sip: scheme if there is none.
+		if (uriStr.toLowerCase().indexOf("sip:") == -1 // no sip scheme
+				&& uriStr.indexOf('@') != -1) // most probably a sip uri
+		{
+			uriStr = "sip:" + uriStr;
+		}
+
+		// Request URI
+		Address uri = protocolProvider.getAddressFactory()
+				.createAddress(uriStr);
+
+		return uri;
+	}
+
+	/**
+	 * Method called by the GUI when the user decides to send a file
+	 * 
+	 * This method generates and sends a SIP INVITE with an SDP offer according
+	 * to the draft-ietf-mmusic-file-transfer-mech-08 that contains a newly
+	 * generated MSRP Session that is going to be used to send the file in the
+	 * case that the Answerer of the INVITE accepts the offer.
+	 * 
+	 * Also the Message object is generated and associated with the newly
+	 * generated MSRP session.
+	 * 
+	 * A new FileTransferSipImpl that encapsulates the Message and Session as
+	 * well as the 'file-transfer-id' is used to generate a new
+	 * FileTransferNewEvent
+	 * 
+	 * @param file
+	 *            the File to be sent
+	 * @param contact
+	 *            the contact to whom one is sending the file to
+	 */
+	@SuppressWarnings("unchecked")
+	@Override
+	public void sendFile(Contact contact, File file)
+			throws FileTransferException {
+		/* Sanity checks: (really don't know if they are needed FIXME (?!) */
+		if (!contact.getProtocolProvider().getProtocolName().equalsIgnoreCase(
+				"SIP")) {
+			logger
+					.error("The sendFile of the SIP File Transfer was called for a non SIP Contact: "
+							+ contact.getDisplayName());
+			throw new FileTransferException();
+		}
+		if (!file.isFile()) {
+			logger.error("The sendFile of the SIP File Transfer was "
+					+ "called with an invalid File as argument");
+			throw new FileTransferException();
+		}
+		// Assuming that the address of Contact.getAdress returns the URI as
+		// Contact comments
+		String contactURIString = contact.getDisplayName();
+		try {
+			Address toAddress = parseAddressStr(contactURIString);
+
+			// create the invite request
+			Request invite = createInviteRequest(toAddress);
+			// Content
+			ContentTypeHeader contentTypeHeader = null;
+			// content type should be application/sdp (not applications)
+			// reported by Oleg Shevchenko (Miratech)
+			contentTypeHeader = protocolProvider.getHeaderFactory()
+					.createContentTypeHeader("application", "sdp");
+
+			// check whether there's a cached authorization header for this
+			// call id and if so - attach it to the request.
+			// add authorization header
+			CallIdHeader call = (CallIdHeader) invite
+					.getHeader(CallIdHeader.NAME);
+			String callid = call.getCallId();
+
+			AuthorizationHeader authorization = protocolProvider
+					.getSipSecurityManager().getCachedAuthorizationHeader(
+							callid);
+
+			if (authorization != null)
+				invite.addHeader(authorization);
+
+			// Transaction
+			ClientTransaction inviteTransaction;
+			SipProvider jainSipProvider = protocolProvider
+					.getDefaultJainSipProvider();
+			try {
+				inviteTransaction = jainSipProvider
+						.getNewClientTransaction(invite);
+			} catch (TransactionUnavailableException ex) {
+				logger.error("Failed to create inviteTransaction.\n"
+						+ "This is most probably a network connection error.",
+						ex);
+				throw new FileTransferException(
+						"Failed to create inviteTransaction.\n"
+								+ "This is most probably a network connection error.",
+						ex);
+			}
+
+			// Generate the MSRP Session used to transfer the file
+
+			// extract the address to use, using the default JAIN-SIP listening
+			// point associated with this protocolProvider
+
+			InetAddress listeningAddress;
+			Session newSession;
+			try {
+
+				listeningAddress = InetAddress.getLocalHost();
+				newSession = new Session(false, false, listeningAddress);
+				// add a handler to the session
+				newSession.addMSRPSessionListener(new MSRPSessionHandler());
+			} catch (Exception e) {
+				logger.error("Error generating MSRP session to send "
+						+ "file over SIP", e);
+				throw new FileTransferException(e);
+			}
+
+			// invite content
+			SdpFactory sdpFactory = SdpFactory.getInstance();
+			SessionDescription sessDescr = sdpFactory
+					.createSessionDescription();
+
+			// "v=0"
+			Version v = sdpFactory.createVersion(0);
+
+			sessDescr.setVersion(v);
+
+			/*
+			 * The Origin o= of the SDP: due to the fact that the "tuple of
+			 * <username>, <session id>, <network type>, <address type> and
+			 * <address> form a globally unique identifier for the session." [as
+			 * in RFC2327] we get a static counter associated with this class
+			 * starting at 1 to differ from the origin used in calls
+			 */
+			String addrType = listeningAddress instanceof Inet6Address ? Connection.IP6
+					: Connection.IP4;
+			// gonna replace the whitespaces in the userid due to the comments
+			// on *.impl.media.CallSessionImpl.java line 928 [although i suspect
+			// it's corrected]
+			String username = protocolProvider.getAccountID().getUserID()
+					.replace(' ', '_');
+			Origin o = sdpFactory.createOrigin(protocolProvider.getAccountID()
+					.getUserID(), getSessionId(), 0, "IN", addrType,
+					listeningAddress.getHostAddress());
+
+			sessDescr.setOrigin(o);
+
+			// s="file-transfer-mech-08 session"
+			SessionName s = sdpFactory
+					.createSessionName("file-transfer-mech-08 session");
+			sessDescr.setSessionName(s);
+
+			// c=
+			Connection c = sdpFactory.createConnection("IN", addrType,
+					listeningAddress.getHostAddress());
+			sessDescr.setConnection(c);
+
+			// t=0 0
+			TimeDescription t = sdpFactory.createTimeDescription();
+			Vector timeDesc = new Vector();
+			timeDesc.add(t);
+
+			sessDescr.setTimeDescriptions(timeDesc);
+
+			// media description.
+			int portNumber = newSession.getURI().getPort();
+			String[] stringArray = { "*" };
+			MediaDescription m = sdpFactory.createMediaDescription("message",
+					portNumber, 1, "TCP/MSRP", stringArray);
+			Info i = sdpFactory.createInfo("Unspecified File");
+			m.setInfo(i);
+
+			Vector mediaDescs = new Vector();
+			mediaDescs.add(m);
+
+			sessDescr.setMediaDescriptions(mediaDescs);
+
+			// attributes
+			String attributesString = new String();
+
+			attributesString = attributesString.concat("a=sendonly\r\n"
+					+ "a=accept-types:*\r\n" + "a=path:"
+					+ newSession.getURI().toString() + "\r\n"
+					+ "a=file-selector:name:\"" + file.getName() + "\" size:"
+					+ file.length() + "\r\n");
+			// file-selector attribute
+			// TODO implement the hash of file selector
+			// with org.bouncycastle.crypto.digests.SHA1Digest.SHA1Digest()
+			// Creating the Message that encapsulates the file
+			// to be transfered
+
+			Message messageToBeSent;
+			try {
+				// TODO the content-type doesn't probably has the correct value
+				messageToBeSent = new FileMessage(newSession,
+						"prs.genericfile/prs.rawbyte", file);
+				messageToBeSent.setSuccessReport(true);
+			} catch (FileNotFoundException e) {
+				logger.error("FileNotFound while transfering the file: " + file
+						+ " to: " + contact.getDisplayName(), e);
+				throw new FileTransferException();
+			} catch (SecurityException e) {
+				logger.error("SecurityException while transfering the file: "
+						+ file + " to: " + contact.getDisplayName(), e);
+				throw new FileTransferException();
+			}
+
+			// file-transfer-id "must be globally unique"
+			// TODO currently the Message id generated doesn't implement the
+			// advice given on the RFC 4975 when it does it will be unique
+			// however use it
+			String fileTransferIdString = messageToBeSent.getMessageID();
+			attributesString = attributesString.concat("a=file-transfer-id:"
+					+ fileTransferIdString + "\r\n");
+
+			// TODO in the future it would be nice to add
+			// the icon support and all but that needs UI implementation
+			// and also that process could change in the process of the
+			// draft becoming a RFC
+
+			// all done, adding all the attributes:
+			String completeSdpString = sessDescr.toString();
+			completeSdpString = completeSdpString.concat(attributesString);
+
+			sessDescr = sdpFactory.createSessionDescription(completeSdpString);
+
+			if (logger.isTraceEnabled()) {
+				logger.trace("Generated SDP - " + sessDescr.toString());
+			}
+
+			// adding the sessDescr to the invite
+			invite.setContent(sessDescr, contentTypeHeader);
+
+			// sending the invite
+			try {
+				inviteTransaction.sendRequest();
+				if (logger.isDebugEnabled())
+					logger.debug("sent request: " + invite);
+			} catch (SipException ex) {
+				logger.error("An error occurred while sending invite request",
+						ex);
+				throw new OperationFailedException(
+						"An error occurred while sending invite request",
+						OperationFailedException.NETWORK_FAILURE, ex);
+			}
+			// Creating the new FileTransferSipImpl object
+			FileTransferSipImpl fileTrSip = new FileTransferSipImpl(newSession,
+					messageToBeSent, fileTransferIdString,
+					(javax.sip.Transaction) inviteTransaction, file.getName(),
+					contact.getDisplayName(), this);
+
+			// FIXME (?!) should it also be a negotiation event here ?!
+			// creating and firing a new file transfer event
+			FileTransferNewEvent ftEvtNew = new FileTransferNewEvent(
+					(FileTransferSC) fileTrSip);
+
+			fireFileTransferEvent(ftEvtNew);
+
+		}
+		// FIXME (?!) maybe catch all the general exceptions
+		// the different catch clauses are here waiting for
+		// the error code system completion
+		catch (ParseException e) {
+			logger.error("exception ocurred while parsing the contact "
+					+ "address, couldn't transfer: " + file.getName()
+					+ " to Contact: " + contact.getDisplayName(), e);
+			// FIXME when the Exception error code is complete
+			throw new FileTransferException(e);
+		} catch (OperationFailedException e) {
+			logger.error("exception ocurred while parsing the contact "
+					+ "address, couldn't transfer: " + file.getName()
+					+ " to Contact: " + contact.getDisplayName(), e);
+			// FIXME when the Exception error code is complete
+			throw new FileTransferException(e);
+		} catch (SdpException e) {
+			logger.error("An SDP exception ocurred while "
+					+ "generating the local sdp description for the file "
+					+ "transfer", e);
+			throw new FileTransferException(e);
+		}
+
+	}
+
+	/**
+	 * Method used to update the counter that is the sessionID
+	 * 
+	 * @return the sessionID associated with the session
+	 */
+	private long getSessionId() {
+		synchronized (sessionID) {
+			return sessionID++;
+		}
+	}
+
+	/**
+	 * Creates an invite request destined for <tt>callee</tt>.
+	 * 
+	 * @param toAddress
+	 *            the sip address of the callee that the request is meant for.
+	 * @return a newly created sip <tt>Request</tt> destined for <tt>callee</tt>
+	 *         .
+	 * @throws OperationFailedException
+	 *             with the correspoding code if creating the request fails.
+	 * @author Emil Ivov
+	 */
+	private Request createInviteRequest(Address toAddress)
+			throws OperationFailedException {
+		InetAddress destinationInetAddress = null;
+		try {
+			destinationInetAddress = InetAddress.getByName(((SipURI) toAddress
+					.getURI()).getHost());
+		} catch (UnknownHostException ex) {
+			throw new IllegalArgumentException(((SipURI) toAddress.getURI())
+					.getHost()
+					+ " is not a valid internet address " + ex.getMessage());
+		}
+		// Call ID
+		CallIdHeader callIdHeader = protocolProvider
+				.getDefaultJainSipProvider().getNewCallId();
+
+		// CSeq
+		CSeqHeader cSeqHeader = null;
+		try {
+			cSeqHeader = protocolProvider.getHeaderFactory().createCSeqHeader(
+					1l, Request.INVITE);
+		} catch (InvalidArgumentException ex) {
+			// Shouldn't happen
+			logger.error("An unexpected erro occurred while"
+					+ "constructing the CSeqHeadder", ex);
+			throw new OperationFailedException(
+					"An unexpected erro occurred while"
+							+ "constructing the CSeqHeadder",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		} catch (ParseException exc) {
+			// shouldn't happen
+			logger.error("An unexpected error occurred while"
+					+ "constructing the CSeqHeadder", exc);
+			throw new OperationFailedException(
+					"An unexpected erro occurred while"
+							+ "constructing the CSeqHeadder",
+					OperationFailedException.INTERNAL_ERROR, exc);
+		}
+
+		// FromHeader
+		String localTag = protocolProvider.generateLocalTag();
+		FromHeader fromHeader = null;
+		ToHeader toHeader = null;
+		try {
+			// FromHeader
+			fromHeader = protocolProvider.getHeaderFactory().createFromHeader(
+					protocolProvider.getOurSipAddress(), localTag);
+
+			// ToHeader
+			toHeader = protocolProvider.getHeaderFactory().createToHeader(
+					toAddress, null);
+		} catch (ParseException ex) {
+			// these two should never happen.
+			logger.error("An unexpected erro occurred while"
+					+ "constructing the ToHeader", ex);
+			throw new OperationFailedException(
+					"An unexpected erro occurred while"
+							+ "constructing the ToHeader",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		}
+
+		// ViaHeaders
+		ArrayList viaHeaders = protocolProvider.getLocalViaHeaders(
+				destinationInetAddress, protocolProvider
+						.getDefaultListeningPoint());
+
+		// MaxForwards
+		MaxForwardsHeader maxForwards = protocolProvider.getMaxForwardsHeader();
+
+		// Contact
+		ContactHeader contactHeader = protocolProvider.getContactHeader();
+
+		Request invite = null;
+		try {
+			invite = protocolProvider.getMessageFactory().createRequest(
+					toHeader.getAddress().getURI(), Request.INVITE,
+					callIdHeader, cSeqHeader, fromHeader, toHeader, viaHeaders,
+					maxForwards);
+
+		} catch (ParseException ex) {
+			// shouldn't happen
+			logger.error("Failed to create invite Request!", ex);
+			throw new OperationFailedException(
+					"Failed to create invite Request!",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		}
+
+		// User Agent
+		UserAgentHeader userAgentHeader = protocolProvider
+				.getSipCommUserAgentHeader();
+		if (userAgentHeader != null)
+			invite.addHeader(userAgentHeader);
+
+		// add the contact header.
+		invite.addHeader(contactHeader);
+
+		return invite;
+	}
+
+	@Override
+	public void processDialogTerminated(DialogTerminatedEvent arg0) {
+		// This must mean that the file transfer is over, however don't do a
+		// thing let the MSRP handler signal it
+	}
+
+	/**
+	 * Process an asynchronously reported IO Exception. Asynchronous IO
+	 * Exceptions may occur as a result of errors during retransmission of
+	 * requests. The transaction state machine requires to report IO Exceptions
+	 * to the application immediately (according to RFC 3261). This method
+	 * enables an implementation to propagate the asynchronous handling of IO
+	 * Exceptions to the application.
+	 * 
+	 * @param exceptionEvent
+	 *            The Exception event that is reported to the application.
+	 */
+	@Override
+	public void processIOException(IOExceptionEvent exceptionEvent) {
+		logger.error("Got an asynchronous exception event. host="
+				+ exceptionEvent.getHost() + " port="
+				+ exceptionEvent.getPort());
+	}
+
+	/**
+	 * Processes a Request received on a SipProvider upon which this SipListener
+	 * is registered.
+	 * <p>
+	 * 
+	 * This method ignores the Requests that are meant for the other SipListener
+	 * based on the SDP offer
+	 * 
+	 * @param requestEvent
+	 *            requestEvent fired from the SipProvider to the
+	 *            <tt>SipListener</tt> representing a Request received from the
+	 *            network.
+	 */
+	@Override
+	public void processRequest(RequestEvent requestEvent) {
+		ServerTransaction serverTransaction = requestEvent
+				.getServerTransaction();
+		SipProvider jainSipProvider = (SipProvider) requestEvent.getSource();
+		Request request = requestEvent.getRequest();
+
+		if (serverTransaction == null) {
+			try {
+				serverTransaction = jainSipProvider
+						.getNewServerTransaction(request);
+			} catch (TransactionAlreadyExistsException ex) {
+				// let's not scare the user and only log a message
+				logger.error("Failed to create a new server"
+						+ "transaction for an incoming request\n"
+						+ "(Next message contains the request)", ex);
+				return;
+			} catch (TransactionUnavailableException ex) {
+				// let's not scare the user and only log a message
+				logger.error("Failed to create a new server"
+						+ "transaction for an incoming request\n"
+						+ "(Next message contains the request)", ex);
+				return;
+			}
+		}
+
+		// INVITE
+		if (request.getMethod().equals(Request.INVITE)) {
+			logger.debug("received INVITE");
+			if (serverTransaction.getDialog().getState() == null) {
+				if (logger.isDebugEnabled())
+					logger.debug("request is an INVITE. Dialog state="
+							+ serverTransaction.getDialog().getState());
+				// process the invite
+				processInvite(jainSipProvider, serverTransaction, request);
+			} else {
+				// TODO FIXME it must support reinvites in order to allow file
+				// transfer abortion
+				logger.error("reINVITE-s are not currently supported.");
+			}
+		}
+		// ACK
+		else if (request.getMethod().equals(Request.ACK)) {
+			processAck(serverTransaction, request);
+		}
+		// BYE
+		else if (request.getMethod().equals(Request.BYE)) {
+			processBye(serverTransaction, request);
+		}
+		// CANCEL
+		else if (request.getMethod().equals(Request.CANCEL)) {
+			processCancel(serverTransaction, request);
+		}
+	}
+
+	/**
+	 * Method used to process the CANCEL requests TODO
+	 * 
+	 * @param serverTransaction
+	 * @param request
+	 */
+	private void processCancel(ServerTransaction serverTransaction,
+			Request request) {
+		// TODO
+		logger.debug("received a CANCEL atm do nothing about it");
+
+	}
+
+	/**
+	 * Method used to process the BYE requests TODO
+	 * 
+	 * @param serverTransaction
+	 * @param request
+	 */
+	private void processBye(ServerTransaction serverTransaction, Request request) {
+		// TODO
+		logger.trace("received a BYE atm do nothing about it");
+
+	}
+
+	/**
+	 * Method used to process the ACK requests TODO
+	 * 
+	 * @param serverTransaction
+	 * @param request
+	 */
+	private void processAck(ServerTransaction serverTransaction, Request request) {
+		// TODO
+		logger.trace("received an ACK atm do nothing about it");
+
+	}
+
+	@Override
+	public void processResponse(ResponseEvent responseEvent) {
+		ClientTransaction clientTransaction = responseEvent
+				.getClientTransaction();
+
+		// find out if this response is meant for us. If not, silently exit
+		String callIdString = clientTransaction.getDialog().getCallId()
+				.getCallId();
+		if (!activeFileTransferRepository.contains(callIdString)) {
+			logger.trace("found an incoming response that is not part of a "
+					+ "file transfer negotiation. Ident. callID: \""
+					+ callIdString + "\"");
+			return;
+		}
+		FileTransferSipImpl originatingFileTransfer = activeFileTransferRepository
+				.getFileTransfer(callIdString);
+
+		Response response = responseEvent.getResponse();
+
+		CSeqHeader cseq = ((CSeqHeader) response.getHeader(CSeqHeader.NAME));
+
+		if (cseq == null) {
+			logger.error("An incoming response did not contain a CSeq header");
+		}
+
+		String method = cseq.getMethod();
+
+		SipProvider sourceProvider = (SipProvider) responseEvent.getSource();
+
+		if (response.getStatusCode() == Response.OK) {
+			if (method.equals(Request.INVITE)) {
+				processInviteOK(clientTransaction, response,
+						originatingFileTransfer);
+			} else if (method.equals(Request.BYE)) {
+				// bye means the file transfer is done (?!)
+				// however expect the MSRP to handle it
+			}
+		}
+		// Ringing
+		else if (response.getStatusCode() == Response.RINGING) {
+			logger.trace("Received a RINGING response");
+			processRinging(clientTransaction, response, originatingFileTransfer);
+			// ^^ ATM does nothing
+		}
+		// Session Progress - Means that the SDP body validated
+		else if (response.getStatusCode() == Response.SESSION_PROGRESS) {
+			logger.trace("Received a SESSION PROGRESS response "
+					+ "SHOULD mean that the SDP Offer validated and request "
+					+ "was present to the user");
+		}
+		// Trying
+		else if (response.getStatusCode() == Response.TRYING) {
+			// do nothing
+			logger.trace("Received a TRYING response");
+		}
+		// Busy here.
+		else if (response.getStatusCode() == Response.BUSY_HERE) {
+			// do nothing (it's not applicable in FileTransfers)
+			logger.debug("Received a 'stray' BUSY HERE response. "
+					+ "this shouldn't be applicable in file transfers");
+		}
+
+		// 401 UNAUTHORIZED
+		else if (response.getStatusCode() == Response.UNAUTHORIZED
+				|| response.getStatusCode() == Response.PROXY_AUTHENTICATION_REQUIRED) {
+			processAuthenticationChallenge(clientTransaction, response,
+					sourceProvider, originatingFileTransfer);
+		}
+		// errors
+		else if (response.getStatusCode() / 100 == 4
+				|| response.getStatusCode() / 100 == 5) {
+			// well, negotiation must have failed then
+
+			// let's fire a FileTransferFailEvent
+			FileTransferFailEvent fileTrnsfrFailEvt = new FileTransferFailEvent(
+					originatingFileTransfer);
+			fireFileTransferEvent(fileTrnsfrFailEvt);
+			// TODO remove the MSRP resources!
+
+		} else if (response.getStatusCode() / 100 == 6) {
+			// once got a 606 response probably one should also trigger a fail
+			// event
+			// these are more serious responses, i think, because it's on the
+			// RFC as:
+			// TODO assert the meaning of a global failure and do something to
+			// remove the file transfer from the active f.t. repository without
+			// appearing a new window :) (also do that on the 4xx and 5xx
+			// responses
+			// Global Failure: this request would fail on any server O_o
+			// This generally happens when you send get an unauthorized and
+			// after successful authorization so the best course of action here
+			// is probably to generate a new request or resend it for this
+			// FileTransfer
+			logger.error("NOTE: Got a 6xx RESPONSE!");
+			// let's fire a FileTransferFailEvent
+			FileTransferFailEvent fileTrnsfrFailEvt = new FileTransferFailEvent(
+					originatingFileTransfer);
+			fireFileTransferEvent(fileTrnsfrFailEvt);
+		}
+		// ignore everything else.
+	}
+
+	/**
+	 * Attempts to re-generate the corresponding request with the proper
+	 * credentials and terminates the file transfer if it fails.
+	 * 
+	 * @param clientTransaction
+	 *            the corresponding transaction
+	 * @param response
+	 *            the challenge
+	 * @param jainSipProvider
+	 *            the provider that received the challende
+	 * 
+	 */
+	private void processAuthenticationChallenge(
+			ClientTransaction clientTransaction, Response response,
+			SipProvider jainSipProvider,
+			FileTransferSipImpl originatingFileTransfer) {
+
+		try {
+			logger.debug("Authenticating an INVITE request.");
+
+			ClientTransaction retryTran = protocolProvider
+					.getSipSecurityManager().handleChallenge(response,
+							clientTransaction, jainSipProvider);
+
+			if (retryTran == null) {
+				logger.trace("No password supplied or error occured!");
+				return;
+			}
+
+			// There is a new dialog that will be started with this request. Get
+			// that dialog and record it into the File Transfer object for later
+			// use (by Bye-s for example).
+			// if the request was BYE then we need to authorize it anyway even
+			// if the call and the call participant are no longer there
+			// ^^ FIXME (?!) present on original Emil's method don't know
+			// exactly what should be done here in the File Transfer case
+			retryTran.sendRequest();
+		} catch (Exception exc) {
+			logger.error("We failed to authenticate an INVITE request.", exc);
+
+			// again, don't know what this changes in the file transfer:
+			// FIXME(?!)
+			// tell the others we couldn't register
+			// callParticipant.setState(CallParticipantState.FAILED);
+		}
+	}
+
+	private void processRinging(ClientTransaction clientTransaction,
+			Response response, FileTransferSipImpl originatingFileTransfer) {
+
+		// TODO (?!) maybe fire a FileTransferNegotiationEvent
+	}
+
+	/**
+	 * Method used to process an OK to an outgoing invite. This method
+	 * invocation could result on starting a file transfer.
+	 * 
+	 * It could result on a premature cancelation of the same depending on the
+	 * media lines
+	 * 
+	 * @param clientTransaction
+	 * @param response
+	 * @param fileTransfer
+	 */
+	private void processInviteOK(ClientTransaction clientTransaction,
+			Response response, FileTransferSipImpl fileTransfer) {
+		// Inspect the sdp body in order to assert what's to be done regarding
+		// this response
+		String sdpResponseContent = new String(response.getRawContent());
+
+		// extract the path to be used by the MSRP session
+		// mine the path for the MSRP uri/uris
+		ArrayList<java.net.URI> path = new ArrayList<java.net.URI>();
+		// the size in the file selector
+		long size = 0;
+		// the name in the file selector with the "" trimmed
+		StringBuffer name = new StringBuffer();
+		// the file-transfer-id in this sdp
+		StringBuffer fileTransferId = new StringBuffer();
+
+		try {
+			mineAndValidateSDP(sdpResponseContent, path, size, name,
+					fileTransferId);
+			// TODO (?!) make sure the m=lines have non zero ports (?!) [is this
+			// only required if we allow multiple m=lines ?!] FIXME Issue #1
+
+			// set up the session accordingly and start transferring the file
+			Session sendingSession = fileTransfer.getSession();
+			sendingSession.addToPath(path);
+		} catch (Exception e) {
+			// TODO fire the cancel(?!) file transfer and release resources
+			logger.error("transfering file: " + fileTransfer.getFileName()
+					+ " to: " + fileTransfer.getContactName());
+			return;
+		}
+
+		// fire the event
+		FileTransferPerformingEvent flTrPrfrmngEvent = new FileTransferPerformingEvent(
+				fileTransfer);
+		fireFileTransferEvent(flTrPrfrmngEvent);
+
+	}
+
+	/**
+	 * Processes a retransmit or expiration Timeout of an underlying
+	 * {@link Transaction}handled by this SipListener. This Event notifies the
+	 * application that a retransmission or transaction Timer expired in the
+	 * SipProvider's transaction state machine. The TimeoutEvent encapsulates
+	 * the specific timeout type and the transaction identifier either client or
+	 * server upon which the timeout occured. The type of Timeout can by
+	 * determined by:
+	 * <code>timeoutType = timeoutEvent.getTimeout().getValue();</code>
+	 * 
+	 * @param timeoutEvent
+	 *            the timeoutEvent received indicating either the message
+	 *            retransmit or transaction timed out.
+	 */
+	@Override
+	public void processTimeout(TimeoutEvent timeoutEvent) {
+		javax.sip.Transaction transaction;
+		if (timeoutEvent.isServerTransaction()) {
+			// don't care. or maybe a stack bug?
+			return;
+		} else {
+			transaction = timeoutEvent.getClientTransaction();
+		}
+
+		FileTransferSipImpl fileTransferSipImpl = activeFileTransferRepository
+				.getFileTransfer(transaction.getDialog().getCallId()
+						.getCallId());
+
+		if (fileTransferSipImpl == null) {
+			logger.debug("Got a headless timeout event." + timeoutEvent);
+			return;
+		}
+
+		// let's fire a file transfer fail event
+		FileTransferFailEvent flTrFailEvent = new FileTransferFailEvent(
+				fileTransferSipImpl);
+		fireFileTransferEvent(flTrFailEvent);
+		// TODO liberate the MSRP resources (?!)
+	}
+
+	@Override
+	public void processTransactionTerminated(TransactionTerminatedEvent arg0) {
+		// nothing to do here
+	}
+
+	/**
+	 * If the SDP is for a file transfer the invite get's processed otherwise
+	 * this funcition exits without doing anything.
+	 * 
+	 * @param sourceProvider
+	 *            the provider containin <tt>sourceTransaction</tt>.
+	 * @param serverTransaction
+	 *            the transaction containing the received request.
+	 * @param invite
+	 *            the Request that we've just received.
+	 */
+	private void processInvite(SipProvider sourceProvider,
+			ServerTransaction serverTransaction, Request invite) {
+		Dialog dialog = serverTransaction.getDialog();
+		logger.trace("received INVITE, dialog state: " + dialog.getState());
+
+		ContentLengthHeader cl = invite.getContentLength();
+
+		String sdpDescription;
+		if (cl != null && cl.getContentLength() > 0) {
+			sdpDescription = new String(invite.getRawContent());
+		} else {
+			// if we have no SDP no point in going on because this isn't
+			// a file transfer
+			logger.trace("Received an empty content invite, silently "
+					+ "discarding it");
+			return;
+		}
+
+		logger.trace("Will verify whether INVITE is properly addressed.");
+		// Are we the one they are looking for?
+		javax.sip.address.URI calleeURI = dialog.getLocalParty().getURI();
+
+		if (calleeURI.isSipURI()) {
+			boolean assertUserMatch = Boolean.valueOf(
+					SipActivator.getConfigurationService().getString(
+							FAIL_CALLS_ON_DEST_USER_MISMATCH)).booleanValue();
+
+			if (assertUserMatch) {
+				// user info is case sensitive according to rfc3261
+				String calleeUser = ((SipURI) calleeURI).getUser();
+				String localUser = ((SipURI) protocolProvider
+						.getOurSipAddress().getURI()).getUser();
+
+				if (calleeUser != null && !calleeUser.equals(localUser)) {
+					logger.trace("received an INVITE that isn't for us "
+							+ "letting the other request handler take care "
+							+ "of it and going to exit the function now");
+					return;
+				}
+			}
+		}
+
+		// let's look at the SDP in order to assert if this invite is for us.
+		// Seen that a file transfer must have an attribute file-selector
+		// present we'll use that to identify if this is meant for us or
+		// not
+		Pattern fileSelectorPattern = Pattern.compile(
+				"(.*)\r\n(a=file-selector:)(.*)", Pattern.DOTALL);
+		Matcher fileSelectorMatcher = fileSelectorPattern
+				.matcher(sdpDescription);
+
+		if (!fileSelectorMatcher.matches()) {
+			logger
+					.trace("Received an invite with an SDP that is not "
+							+ "meant for this function. SDP content: "
+							+ sdpDescription);
+			return;
+		}
+
+		// Send RINGING
+		logger.debug("Invite seems ok, we'll say RINGING.");
+		Response ringing = null;
+		try {
+			ringing = protocolProvider.getMessageFactory().createResponse(
+					Response.RINGING, invite);
+			protocolProvider.attachToTag(ringing, dialog);
+			ringing.setHeader(protocolProvider.getSipCommUserAgentHeader());
+
+			// set our display name
+			((ToHeader) ringing.getHeader(ToHeader.NAME)).getAddress()
+					.setDisplayName(protocolProvider.getOurDisplayName());
+
+			ringing.addHeader(protocolProvider.getContactHeader());
+		} catch (ParseException ex) {
+			logger.error("Error while trying to send a request", ex);
+			return;
+		}
+		try {
+			logger.trace("will send ringing response: ");
+			serverTransaction.sendResponse(ringing);
+			logger.debug("sent a ringing response: " + ringing);
+		} catch (Exception ex) {
+			logger.error("Error while trying to send a request", ex);
+			return;
+		}
+
+		try {
+			// process the identified sip file request
+			processSipFileRequest(sourceProvider, serverTransaction, invite);
+		} catch (Exception e) {
+			logger.debug("an error ocurred parsing the SDP of what "
+					+ "should have been an incoming SipFileRequest", e);
+			Response badRequest;
+			try {
+				badRequest = protocolProvider.getMessageFactory()
+						.createResponse(Response.NOT_IMPLEMENTED, invite);
+				protocolProvider.attachToTag(badRequest, dialog);
+				badRequest.setHeader(protocolProvider
+						.getSipCommUserAgentHeader());
+
+				// set our display name
+				((ToHeader) badRequest.getHeader(ToHeader.NAME)).getAddress()
+						.setDisplayName(protocolProvider.getOurDisplayName());
+			} catch (ParseException ex) {
+				logger.error("Error while trying to send a request response",
+						ex);
+				return;
+			}
+			try {
+				logger.trace("will send badrequest response: ");
+				serverTransaction.sendResponse(badRequest);
+				logger.debug("sent a badrequest response: " + badRequest);
+				return;
+			} catch (Exception ex) {
+				logger.error("Error while trying to send a response", ex);
+			}
+		}
+		// respond with a Session Progress
+		Response sessionProgress;
+		try {
+			sessionProgress = protocolProvider.getMessageFactory()
+					.createResponse(Response.SESSION_PROGRESS, invite);
+			protocolProvider.attachToTag(sessionProgress, dialog);
+			sessionProgress.setHeader(protocolProvider
+					.getSipCommUserAgentHeader());
+
+			// set our display name
+			((ToHeader) sessionProgress.getHeader(ToHeader.NAME)).getAddress()
+					.setDisplayName(protocolProvider.getOurDisplayName());
+		} catch (ParseException ex) {
+			logger.error("Error while trying to send a request", ex);
+			return;
+		}
+		try {
+			logger.trace("will send session progress response: ");
+			serverTransaction.sendResponse(sessionProgress);
+			logger
+					.debug("sent a session progress response: "
+							+ sessionProgress);
+			return;
+		} catch (Exception ex) {
+			logger.error("Error while trying to send a response", ex);
+		}
+
+	}
+
+	/**
+	 * Method used to process the invite that apparently is a valid sip file
+	 * transfer.
+	 * 
+	 * This method should be called with an invite that is meant for us
+	 * 
+	 * 
+	 * @param sourceProvider
+	 *            the provider containing <tt>sourceTransaction</tt>.
+	 * @param serverTransaction
+	 *            the transaction containing the received request.
+	 * @param invite
+	 *            the Request that we've just received.
+	 * @throws FileTransferIllegalSdpException
+	 *             if there was an error with the Sdp and therefore this isn't a
+	 *             valid file transfer INVITE as it should
+	 */
+	private void processSipFileRequest(SipProvider sourceProvider,
+			ServerTransaction serverTransaction, Request invite)
+			throws FileTransferIllegalSdpException {
+		// let's mine the sdp for the needed fields and parse them
+		// to the FileTransferSipImpl
+
+		// mine the path for the MSRP uri/uris
+		ArrayList<java.net.URI> path = new ArrayList<java.net.URI>();
+		String sdpContent = new String(invite.getRawContent());
+		// the size in the file selector
+		long size = 0;
+		// the name in the file selector with the "" trimmed
+		StringBuffer name = new StringBuffer();
+		// the file-transfer-id in this sdp
+		StringBuffer fileTransferId = new StringBuffer();
+
+		mineAndValidateSDP(sdpContent, path, size, name, fileTransferId);
+		logger.trace("After mineAndValidateSDP, Got the ID:" + fileTransferId);
+
+		// TODO support reINVITEs therefore checking for the uniqueness of the
+		// file-transfer-id TODO suggestion with the
+		// ActiveFileTransferRepository
+
+		// create the event with the FileTransferSipImpl and fire it
+		FileTransferSipImpl fileTrSip = new FileTransferSipImpl(path,
+				fileTransferId.toString(), name.toString(), size, invite,
+				(javax.sip.Transaction) serverTransaction, this);
+
+		FileTransferNewEvent ftEvtNew = new FileTransferNewEvent(
+				(FileTransferSC) fileTrSip);
+
+		fireFileTransferEvent(ftEvtNew);
+	}
+
+	/**
+	 * Method used to mine and validate the sdpContent representing the body of
+	 * an SDP answer/offer.
+	 * 
+	 * @param sdpContent
+	 *            the sdpContent to validate and mine
+	 * @param path
+	 *            and empty ArrayList used to place the MSRP uris found on the
+	 *            SDP
+	 * @param size
+	 *            the long used to put the mined size, if any found.
+	 * @param name
+	 *            the String used to put the file name, if any found.
+	 * @param fileTransferId
+	 *            the String used to put the file-transfer-id attribute, if any
+	 *            found.
+	 * @throws FileTransferIllegalSdpException
+	 *             if this sdp doesn't validate as a File Transfer SDP
+	 */
+	private void mineAndValidateSDP(String sdpContent,
+			ArrayList<java.net.URI> path, long size, StringBuffer name,
+			StringBuffer fileTransferId) throws FileTransferIllegalSdpException {
+
+		String[] sdpLines = sdpContent.split("\r\n");
+		boolean foundPath = false;
+		boolean foundFileSelector = false;
+		boolean foundFileTransferId = false;
+		for (int i = 0; i < sdpLines.length; i++) {
+			int indexPath = sdpLines[i].indexOf("a=path");
+			if (indexPath != -1) {
+				if (foundPath)
+					// in this impl. only one path allowed per sdp
+					throw new FileTransferIllegalSdpException(
+							"Only one path allowed per SDP");
+				foundPath = true;
+				// take the a=path: away
+				int startUris = sdpLines[i].indexOf(':', indexPath) + 1;
+				String uriContainerString = sdpLines[i].substring(startUris);
+				// parse all of the uris that are delimited by spaces
+				String[] Uris = uriContainerString.split(" ");
+				for (String string : Uris) {
+					try {
+						path.add(new java.net.URI(string));
+					} catch (URISyntaxException e) {
+						throw new FileTransferIllegalSdpException(
+								"Illegal parsing of URI", e);
+					}
+				}
+
+				// empty the used up string
+				sdpLines[i] = new String();
+				continue;
+			}// if (indexPath != -1)
+
+			// mine the file-selector for the size and path
+			int indexFileSelector = sdpLines[i].indexOf("a=file-selector");
+			if (indexFileSelector != -1) {
+				if (foundFileSelector)
+					// in this impl. only one file selector allowed per sdp
+					throw new FileTransferIllegalSdpException(
+							"Only one file selector allowed per SDP");
+				foundFileSelector = true;
+
+				// extract the size and the name, if they exist
+				int indexSize = sdpLines[i].indexOf("size:");
+				if (indexSize != -1) {
+					// get the size numerical characters end index
+					int j = indexSize + 5;
+					for (; j < sdpLines[i].length()
+							&& Character.isDigit(sdpLines[i].charAt(j)); j++)
+						;
+					// retrieve the size
+					if (j > indexSize + 5)
+						size = Long.parseLong(sdpLines[i].substring(
+								indexSize + 5, j));
+				}
+
+				int indexName = sdpLines[i].indexOf("name:");
+				if (indexName != -1) {
+					// get the index of the quotes:
+					int indexStartQuote = indexName + 5;
+					int indexEndQuote = sdpLines[i].lastIndexOf('"');
+					if (indexEndQuote != -1 && indexStartQuote != indexEndQuote)
+						name.append(sdpLines[i].substring(++indexStartQuote,
+								indexEndQuote));
+
+				}
+
+				// check that at least one of type size or hash exist
+				if (!(indexSize != -1 || sdpLines[i].indexOf("hash") != -1 || sdpLines[i]
+						.indexOf("type") != -1))
+					throw new FileTransferIllegalSdpException("at least one "
+							+ "of type size or hash must exist");
+				// empty the used up string
+				sdpLines[i] = new String();
+				continue;
+			}// if (indexFileSelector != -1)
+
+			// mine the file-transfer-id:
+			int indexFileTransferId = sdpLines[i].indexOf("file-transfer-id:");
+			if (indexFileTransferId != -1) {
+				if (foundFileTransferId)
+					throw new FileTransferIllegalSdpException(
+							"Only one file transfer id allowed per SDP");
+				foundFileTransferId = true;
+				// extract the file transfer id
+				fileTransferId.append(sdpLines[i]
+						.substring(indexFileTransferId + 17));
+
+				// empty the used up string
+				sdpLines[i] = new String();
+				continue;
+			}
+		} // end of the mining algorithm
+
+		// TODO FIXME Issue #XX one should add
+		// check that we have at least one path and one file transfer id
+		if (path.isEmpty() || fileTransferId == null)
+			throw new FileTransferIllegalSdpException(
+					"the SDP must have at least one path and a file transfer id");
+		logger.trace("In mineAndValidateSDP got the ID:" + fileTransferId);
+	}
+
+	/**
+	 * Method that sends the 2xx OK response and that sets the MSRP session to
+	 * receive the file
+	 * 
+	 * @param incomingFile
+	 * @param firstTransaction
+	 * @param invite
+	 * @param fileTransferId
+	 * @throws OperationFailedException
+	 */
+	protected void acceptFile(File incomingFile,
+			FileTransferSipImpl incFileTransfer)
+			throws OperationFailedException {
+		/*
+		 * repeating "sanity checks"(?!) that appeared on answerCallParticipant
+		 */
+		javax.sip.Transaction firstTransaction = incFileTransfer
+				.getInviteTransaction();
+
+		Request invite = incFileTransfer.getInvite();
+		if (firstTransaction == null) {
+			throw new OperationFailedException(
+					"Failed to extract a ServerTransaction "
+							+ "from the call's associated dialog!",
+					OperationFailedException.INTERNAL_ERROR);
+		}
+		if (invite == null) {
+			throw new OperationFailedException(
+					"Failed to accept file transfer because the invite"
+							+ " was null!",
+					OperationFailedException.INTERNAL_ERROR);
+		}
+		ServerTransaction serverTransaction = (ServerTransaction) firstTransaction;
+
+		Dialog dialog = serverTransaction.getDialog();
+
+		if (!dialog.isServer())
+			throw new OperationFailedException(
+					"Failed to extract a ServerTransaction "
+							+ "from the call's associated dialog!",
+					OperationFailedException.INTERNAL_ERROR);
+
+		// Create the skeleton of the ok response:
+		Response ok = null;
+		try {
+			ok = protocolProvider.getMessageFactory().createResponse(
+					Response.OK, invite);
+			ok.setHeader(protocolProvider.getSipCommUserAgentHeader());
+			protocolProvider.attachToTag(ok, dialog);
+
+		} catch (ParseException ex) {
+			logger.error(
+					"Failed to construct an OK response to an INVITE request",
+					ex);
+			throw new OperationFailedException(
+					"Failed to construct an OK response to an INVITE request",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		}
+
+		// add the content
+		ContentTypeHeader contentTypeHeader = null;
+		try {
+			contentTypeHeader = protocolProvider.getHeaderFactory()
+					.createContentTypeHeader("application", "sdp");
+		} catch (ParseException ex) {
+			// Shouldn't happen
+			logger
+					.error(
+							"Failed to create a content type header for the OK response",
+							ex);
+			throw new OperationFailedException(
+					"Failed to create a content type header for the OK response",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		}
+		try {
+			String sdp = null;
+			// if the offer was in the invite create an sdp answer
+			if (invite.getRawContent() != null
+					&& invite.getRawContent().length > 0) {
+
+				// this is the core of the SDP processing and answer generation
+				sdp = processSdpOffer(new String(invite.getRawContent()),
+						incomingFile, incFileTransfer.getToPath());
+			}
+			// if there was no offer in the invite, we have ourselves an
+			// internal
+			// error
+			else {
+
+				logger.error("accept file error due to an internal error "
+						+ "it should have had an SDP body");
+				throw new OperationFailedException("it should have had an "
+						+ "SDP body at this point",
+						OperationFailedException.INTERNAL_ERROR);
+			}
+			ok.setContent(sdp, contentTypeHeader);
+		} catch (Exception ex) {
+			logger.error(
+					"Failed to parse sdp data while creating invite request!",
+					ex);
+			throw new OperationFailedException(
+					"Failed to parse sdp data while creating invite request!",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		}
+
+		ContactHeader contactHeader = protocolProvider.getContactHeader();
+		ok.addHeader(contactHeader);
+		try {
+
+			serverTransaction.sendResponse(ok);
+			if (logger.isDebugEnabled())
+				logger.debug("sent response\n" + ok);
+		} catch (Exception ex) {
+			logger.error("Failed to send an OK response to an INVITE request",
+					ex);
+			throw new OperationFailedException(
+					"Failed to send an OK response to an INVITE request",
+					OperationFailedException.NETWORK_FAILURE, ex);
+		}
+
+	}
+
+	/**
+	 * Generates the SDP answer based on the previous offer given to this method
+	 * by the sdpOffer parameter.
+	 * 
+	 * Creates the MSRP session and sets the conditions to accept the next
+	 * message to be written to the file Generates the SDP offer based on the
+	 * newly generated Session
+	 * 
+	 * @param sdpOffer
+	 *            a string representation of the sdp offer that triggered this
+	 *            file transfer
+	 * @param file
+	 *            the file to be used by the MSRP data container of the message
+	 * @param toPath
+	 *            the to path used to generate and activate the MSRP session
+	 * @throws Exception
+	 *             if an error occurred processing the SDP answer
+	 * @return the SDP body representing the answer to the received offer
+	 */
+	private String processSdpOffer(String sdpOffer, File file,
+			ArrayList<java.net.URI> toPath) throws Exception
+
+	{
+		String toReturnString;
+		InetAddress listeningAddress;
+		Session receivingSession;
+		try {
+
+			listeningAddress = InetAddress.getLocalHost();
+			receivingSession = new Session(false, false, toPath.get(toPath
+					.size() - 1), listeningAddress);
+			MSRPSessionHandler receivingHandler;
+			try {
+				receivingHandler = new MSRPSessionHandler(file);
+
+			} catch (Exception ex) {
+				logger.error("accept hook encountered an exception, "
+						+ "this shouldn't have happened to prevent "
+						+ "check for file existence and accessibility", ex);
+				// FIXME (?!) fire something in order to notify cancellation
+				// of the file transfer
+				throw new FileTransferException(ex);
+			}
+			// add a handler to the session
+			receivingSession.addMSRPSessionListener(receivingHandler);
+			// get the
+		} catch (Exception e) {
+			logger.error("Error generating MSRP session to send "
+					+ "file over SIP", e);
+			throw new FileTransferException(e);
+		}
+
+		SdpFactory sdpFactory = SdpFactory.getInstance();
+		SessionDescription sessDescr = sdpFactory.createSessionDescription();
+
+		// "v=0"
+		Version v = sdpFactory.createVersion(0);
+
+		sessDescr.setVersion(v);
+
+		/*
+		 * The Origin o= of the SDP: due to the fact that the "tuple of
+		 * <username>, <session id>, <network type>, <address type> and
+		 * <address> form a globally unique identifier for the session." [as in
+		 * RFC2327] we get a static counter associated with this class starting
+		 * at 1 to differ from the origin used in calls
+		 */
+		String addrType = listeningAddress instanceof Inet6Address ? Connection.IP6
+				: Connection.IP4;
+		// gonna replace the whitespaces in the userid due to the comments
+		// on *.impl.media.CallSessionImpl.java line 928
+		String username = protocolProvider.getAccountID().getUserID().replace(
+				' ', '_');
+		Origin o = sdpFactory.createOrigin(protocolProvider.getAccountID()
+				.getUserID(), getSessionId(), 0, "IN", addrType,
+				listeningAddress.getHostAddress());
+
+		sessDescr.setOrigin(o);
+
+		// s="file-transfer-mech-08 session"
+		SessionName s = sdpFactory
+				.createSessionName("file-transfer-mech-08 session");
+		sessDescr.setSessionName(s);
+
+		// c=
+		Connection c = sdpFactory.createConnection("IN", addrType,
+				listeningAddress.getHostAddress());
+		sessDescr.setConnection(c);
+
+		// t=0 0
+		TimeDescription t = sdpFactory.createTimeDescription();
+		Vector timeDesc = new Vector();
+		timeDesc.add(t);
+
+		sessDescr.setTimeDescriptions(timeDesc);
+
+		// media description.
+		int portNumber = receivingSession.getURI().getPort();
+		String[] stringArray = { "*" };
+		MediaDescription m = sdpFactory.createMediaDescription("message",
+				portNumber, 1, "TCP/MSRP", stringArray);
+		Info i = sdpFactory.createInfo("Unspecified File");
+		m.setInfo(i);
+
+		Vector mediaDescs = new Vector();
+		mediaDescs.add(m);
+
+		sessDescr.setMediaDescriptions(mediaDescs);
+
+		// attributes
+		String attributesSdp = new String();
+
+		attributesSdp = attributesSdp.concat("a=recvonly\r\n"
+				+ "a=accept-types:*\r\n" + "a=path:"
+				+ receivingSession.getURI().toString() + "\r\n");
+
+		// adding all the attributes:
+		String completeSdpString = sessDescr.toString();
+		completeSdpString = completeSdpString.concat(attributesSdp);
+
+		sessDescr = sdpFactory.createSessionDescription(completeSdpString);
+
+		toReturnString = sessDescr.toString();
+
+		// file-selector attribute must be copied
+		int indexFileSelectorStart = sdpOffer.indexOf("a=file-selector");
+		int indexFileSelectorEnd = sdpOffer.indexOf("\r\n",
+				indexFileSelectorStart);
+		String fileSelectorString = sdpOffer.substring(indexFileSelectorStart,
+				indexFileSelectorEnd);
+
+		// file-transfer-id "must be globaly unique"
+		// and copied from the offer
+		int indexFileTrIdStart = sdpOffer.indexOf("a=file-transfer-id");
+		int indexFileTrIdEnd = sdpOffer.indexOf("\r\n", indexFileTrIdStart);
+		String fileTrIdString = sdpOffer.substring(indexFileTrIdStart,
+				indexFileTrIdEnd);
+
+		toReturnString = toReturnString.concat(fileSelectorString + "\r\n"
+				+ fileTrIdString + "\r\n");
+
+		// also the file-range, if present, should be copied
+		int indexFileRangeStart = sdpOffer.indexOf("a=file-range");
+
+		if (indexFileRangeStart != -1) {
+			String fileRangeString = sdpOffer.substring(indexFileRangeStart,
+					sdpOffer.indexOf("\r\n"));
+			toReturnString = toReturnString.concat(fileRangeString + "\r\n");
+		}
+
+		if (logger.isTraceEnabled()) {
+			logger.trace("Generated SDP - " + toReturnString);
+		}
+
+		return toReturnString;
+	}
+
+	/**
+	 * Delivers the specified event to all registered fileTransflisteners.
+	 * 
+	 * @param evt
+	 *            the <tt>EventObject</tt> that we'd like delivered to all
+	 *            registered fileTransfer listerners.
+	 * 
+	 *            TODO (?!) Refactoring suggestion: OperationSetFileTransfer as
+	 *            an abstract class with this method as final, as indeed this
+	 *            method is alike for all implementations
+	 */
+	private void fireFileTransferEvent(EventObject evt) {
+		Iterator listeners = null;
+		synchronized (fileTransferListeners) {
+			listeners = new ArrayList(fileTransferListeners).iterator();
+		}
+		while (listeners.hasNext()) {
+			FileTransfListener listener = (FileTransfListener) listeners.next();
+
+			if (evt instanceof FileTransferNewEvent) {
+				listener.notifyNewFileTransfer((FileTransferNewEvent) evt);
+			} else if (evt instanceof FileTransferNegotiationEvent) {
+				listener.notifyNegotiation((FileTransferNegotiationEvent) evt);
+			} else if (evt instanceof FileTransferDoneEvent) {
+				listener.notifyDone((FileTransferDoneEvent) evt);
+			} else if (evt instanceof FileTransferProgressEvent) {
+				listener.setProgress((FileTransferProgressEvent) evt);
+			} else if (evt instanceof FileTransferFailEvent) {
+				listener.notifyFail((FileTransferFailEvent) evt);
+			} else if (evt instanceof FileTransferPerformingEvent) {
+				listener.notifyTransfer((FileTransferPerformingEvent) evt);
+			} else if (evt instanceof FileTransferCancelEvent) {
+				listener.notifyCancel((FileTransferCancelEvent) evt);
+			} else if (evt instanceof FileTransferWaitingEvent) {
+				listener.notifyWaiting((FileTransferWaitingEvent) evt);
+			}
+		}
+	}
+
+	/**
+	 * Class used to interface with the MSRP Session
+	 * 
+	 * @author João André Pereira Antunes
+	 * 
+	 */
+	class MSRPSessionHandler implements MSRPSessionListener {
+		private FileDataContainer dataContainer = null;
+
+		private boolean acceptResult = false;
+
+		/**
+		 * Constructor called to generate a version that accepts one message of
+		 * the handler
+		 * 
+		 * Note: this constructor should be used on receiving sessions. Note: an
+		 * MSRP session should only be used to transfer one file.
+		 * 
+		 * @param dataContainerFile
+		 * @throws Exception
+		 *             if there was any kind of exception creating the
+		 *             DataContainer
+		 */
+		MSRPSessionHandler(File dataContainerFile)
+				throws FileNotFoundException, Exception {
+			this();
+			this.dataContainer = new FileDataContainer(dataContainerFile);
+			this.acceptResult = true;
+
+		}
+
+		public MSRPSessionHandler() {
+			logger.trace("Created a MSRPSessionHandler");
+		}
+
+		@Override
+		public boolean acceptHook(Session session, IncomingMessage message) {
+			logger.trace("Called the acceptHook with message id: "
+					+ message.getMessageID());
+			if (acceptResult) {
+				FileDataContainer fileDataContainer;
+				message.setDataContainer(dataContainer);
+				acceptResult = false;
+				FileTransferSipImpl fileTransfer = activeFileTransferRepository
+						.getFileTransferById(message.getMessageID());
+
+				if (fileTransfer == null) {
+					logger.error("**FILE TRANSFER** implementation error, "
+							+ "couldn't retrieve FileTransfer instance");
+					// TODO probably return false here and signal the
+					// other side, aborting the file transfer.
+					// see abort scenarios, this corresponds to the one where
+					// a 413 is sent and then an SDP should be sent
+				} else {
+					// Store and associate the message and session with the file
+					// transfer (used mainly to release resources posteriorly)
+					fileTransfer.setAssociatedMessage(message);
+					fileTransfer.setAssociatedSession(session);
+
+				}
+
+				FileTransferPerformingEvent flTrPrfmingEvent = new FileTransferPerformingEvent(
+						fileTransfer);
+				fireFileTransferEvent(flTrPrfmingEvent);
+				return true;
+			}
+			return acceptResult;
+		}
+
+		/**
+		 * Method used to notify the completion of the received Message (that
+		 * represents a file transfer)
+		 */
+		@Override
+		public void receiveMessage(Session session, Message message) {
+			logger.trace("RECEIVED the message: "
+					+ message.getMessageID()
+					+ " with associated FileName: "
+					+ ((FileDataContainer) message.getDataContainer())
+							.getFile().getName());
+			// get the FileTransfer
+			FileTransferSipImpl flTrSipImpl = activeFileTransferRepository
+					.getFileTransferById(message.getMessageID());
+
+			//TODO FIXME Issue #12 send a BYE response 
+			
+			// fire a file received event (actually seems that a done event is
+			// the right kind of event)
+			FileTransferDoneEvent flTrDoneEvent = new FileTransferDoneEvent(
+					flTrSipImpl);
+			fireFileTransferEvent(flTrDoneEvent);
+
+			// Release the resources associated with this FileTransfer
+			flTrSipImpl.releaseResources();
+
+		}
+
+		@Override
+		public void receivedReport(Session arg0, Transaction transaction) {
+			logger.trace("received a REPORT for message id: "
+					+ transaction.getMessage().getMessageID()
+					+ " success report with value: "
+					+ transaction.getSuccessReport());
+			// update the progress bar or report the file has been
+			// completely transfered accordingly
+			FileTransferSipImpl fileTransfer = activeFileTransferRepository
+					.getFileTransferById(transaction.getMessageID());
+			if (transaction.getMessage().isComplete()) {
+				// fire a FileDone event because the file is completely sent
+				FileTransferDoneEvent event = new FileTransferDoneEvent(
+						fileTransfer);
+				fireFileTransferEvent(event);
+				// also dispose of all the resources occupied by this file
+				// transfer:
+				fileTransfer.releaseResources();
+			} else {
+				// it's a partial report, we get the last byte reported
+				// and assume that's the last byte correctly received by the
+				// other part
+				long bytesAckReceived = transaction.getByteRange()[1];
+				long totalMessageBytes = transaction.getTotalMessageBytes();
+				int percentageProgress;
+				// if we have an unintialized/unknown total number of bytes,
+				// exit quietly
+				if (totalMessageBytes < 0)
+					return;
+				else
+					percentageProgress = (int) (bytesAckReceived * 100 / totalMessageBytes);
+
+				FileTransferProgressEvent event = new FileTransferProgressEvent(
+						fileTransfer, percentageProgress);
+				fireFileTransferEvent(event);
+			}
+		}
+
+		@Override
+		public void updateSendStatus(Session arg0, Message message,
+				long sentBytes) {
+			logger.trace("Called the updateSendStatus for message id: "
+					+ message.getMessageID() + " reporting that " + sentBytes
+					+ "bytes have been sent");
+			FileTransferSipImpl fileTransfer = activeFileTransferRepository
+					.getFileTransferById(message.getMessageID());
+			if (message.isComplete()) {// fire a FileDone event because the file
+				// is completely sent
+				FileTransferDoneEvent event = new FileTransferDoneEvent(
+						fileTransfer);
+				fireFileTransferEvent(event);
+				// also dispose of all the resources occupied by this file
+				// transfer:
+				fileTransfer.releaseResources();
+
+			} else {
+				// update the progress bar by firing a FileProgressEvent
+				int currentPercntgeProgress = (int) (sentBytes * 100 / message
+						.getSize());
+
+				if (fileTransfer == null) {
+					// this really shouldn't happen.
+					logger.error("**FILE TRANSFER** implementation error, "
+							+ "couldn't retrieve FileTransfer instance "
+							+ "on updateSendStatus!!");
+
+				}
+				FileTransferProgressEvent progressEvent = new FileTransferProgressEvent(
+						fileTransfer, currentPercntgeProgress);
+				fireFileTransferEvent(progressEvent);
+			}
+		}
+
+	}
+
+}
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/ActiveFileTransferRepository.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/ActiveFileTransferRepository.java	(revision 0)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/ActiveFileTransferRepository.java	(revision 4319)
@@ -0,0 +1,165 @@
+/**
+ * 
+ */
+package net.java.sip.communicator.impl.protocol.sip;
+
+import java.util.Hashtable;
+
+import net.java.sip.communicator.service.protocol.event.*;
+import net.java.sip.communicator.util.Logger;
+
+/**
+ * Class that keeps a list of all ActiveFileTransfers. This list is mantained by
+ * the ProtocolProvider that is associated with this class
+ * 
+ * Offers methods to find a FileTransfer based on the dialog which has the
+ * callID
+ * 
+ * @author João André Pereira Antunes
+ * 
+ */
+public class ActiveFileTransferRepository implements FileTransfListener {
+	private static final Logger logger = Logger
+			.getLogger(ActiveCallsRepository.class);
+
+	/**
+	 * The operation set that created us. Instance is mainly used for firing
+	 * events when necessary.
+	 */
+	private OperationSetFileTransferSipImpl parentOperationSet = null;
+
+	/**
+	 * A table mapping call ids against FileTransfer instances.
+	 */
+	private Hashtable activeFileTransfers = new Hashtable();
+
+	/**
+	 * A table mapping file-transfer-id (and MSRP message ID) against
+	 * FileTransfer instances.
+	 */
+	private Hashtable activeFileTransfersById = new Hashtable();
+
+	public ActiveFileTransferRepository(OperationSetFileTransferSipImpl opSet) {
+		this.parentOperationSet = opSet;
+		opSet.addFileTransfListeners(this);
+	}
+
+	@Override
+	public void notifyCancel(FileTransferCancelEvent evt) {
+		synchronized (this) {
+			FileTransferSipImpl fileTrSipImpl = (FileTransferSipImpl) evt
+					.getRequest();
+			logger.trace("UNREGISTERING callID: " + fileTrSipImpl.getCallID()
+					+ " on ActiveFileTransferRepository instance");
+			activeFileTransfers.remove(fileTrSipImpl.getCallID());
+			activeFileTransfersById.remove(fileTrSipImpl.getFileTransferId());
+		}
+	}
+
+	@Override
+	public void notifyDone(FileTransferDoneEvent evt) {
+		synchronized (this) {
+			FileTransferSipImpl fileTrSipImpl = (FileTransferSipImpl) evt
+					.getRequest();
+			logger.trace("UNREGISTERING callID: " + fileTrSipImpl.getCallID()
+					+ " on ActiveFileTransferRepository instance");
+			activeFileTransfers.remove(fileTrSipImpl.getCallID());
+			activeFileTransfersById.remove(fileTrSipImpl.getFileTransferId());
+		}
+	}
+
+	@Override
+	public void notifyFail(FileTransferFailEvent evt) {
+		synchronized (this) {
+			FileTransferSipImpl fileTrSipImpl = (FileTransferSipImpl) evt
+					.getRequest();
+			logger.trace("UNREGISTERING callID: " + fileTrSipImpl.getCallID()
+					+ " on ActiveFileTransferRepository instance");
+			activeFileTransfers.remove(fileTrSipImpl.getCallID());
+			activeFileTransfersById.remove(fileTrSipImpl.getFileTransferId());
+		}
+	}
+
+	@Override
+	public void notifyNegotiation(FileTransferNegotiationEvent evt) {
+		synchronized (this) {
+			FileTransferSipImpl fileTrSipImpl = (FileTransferSipImpl) evt
+					.getRequest();
+			logger.trace("Registering callID: " + fileTrSipImpl.getCallID()
+					+ " on ActiveFileTransferRepository instance");
+			activeFileTransfers.put(fileTrSipImpl.getCallID(), fileTrSipImpl);
+			activeFileTransfersById.put(fileTrSipImpl.getFileTransferId(),
+					fileTrSipImpl);
+		}
+
+	}
+
+	@Override
+	public void notifyNewFileTransfer(FileTransferNewEvent evt) {
+		synchronized (this) {
+			FileTransferSipImpl fileTrSipImpl = (FileTransferSipImpl) evt
+					.getRequest();
+			logger.trace("Registering callID: " + fileTrSipImpl.getCallID()
+					+ " on ActiveFileTransferRepository instance");
+			activeFileTransfers.put(fileTrSipImpl.getCallID(), fileTrSipImpl);
+			activeFileTransfersById.put(fileTrSipImpl.getFileTransferId(),
+					fileTrSipImpl);
+		}
+
+	}
+
+	@Override
+	public void notifyTransfer(FileTransferPerformingEvent evt) {/* dummy method */
+	}
+
+	@Override
+	public void notifyWaiting(FileTransferWaitingEvent evt) {/* dummy method */
+	}
+
+	@Override
+	public void setProgress(FileTransferProgressEvent evt) {/* dummy method */
+	}
+
+	/**
+	 * Method used to assert if the given callId represents an active file
+	 * transfer or not
+	 * 
+	 * @param callIdString
+	 *            the String representing the SIP CallID
+	 * @return true if the callIdString belongs to an active file transfer,
+	 *         false otherwise
+	 */
+	protected boolean contains(String callIdString) {
+		synchronized (this) {
+			return activeFileTransfers.containsKey(callIdString);
+		}
+	}
+
+	/**
+	 * Method used to retrieve the associated file transfer using the caller id
+	 * 
+	 * @param callIdString
+	 *            the String with the SIP CallID
+	 * @return the FileTrasnferSipImpl associated with the given callIdString
+	 */
+	protected FileTransferSipImpl getFileTransfer(String callIdString) {
+		synchronized (this) {
+			return (FileTransferSipImpl) activeFileTransfers.get(callIdString);
+		}
+	}
+
+	/**
+	 * Method used to retrieve the associated file transfer using the transfer
+	 * id
+	 * 
+	 * @param transferId
+	 *            the String with the file-transfer-id
+	 * @return the FileTrasnferSipImpl associated with the given transferId
+	 */
+	protected FileTransferSipImpl getFileTransferById(String transferId) {
+		synchronized (this) {
+			return (FileTransferSipImpl) activeFileTransfersById
+					.get(transferId);
+		}
+	}
+}
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/FileTransferSipImpl.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/FileTransferSipImpl.java	(revision 0)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/FileTransferSipImpl.java	(revision 4319)
@@ -0,0 +1,313 @@
+/**
+ * 
+ */
+package net.java.sip.communicator.impl.protocol.sip;
+
+import java.io.*;
+import java.util.*;
+import java.net.*;
+
+import javax.sip.message.*;
+import javax.sip.header.*;
+import javax.sip.*;
+
+import msrp.*;
+import net.java.sip.communicator.service.protocol.*;
+import net.java.sip.communicator.util.*;
+
+/**
+ * @author João André Pereira Antunes
+ * 
+ */
+public class FileTransferSipImpl implements FileTransferSC {
+	/**
+	 * Logger
+	 */
+	private static final Logger logger = Logger
+			.getLogger(FileTransferSipImpl.class);
+
+	/**
+	 * An instance of the OperationSetFileTransfer
+	 */
+	private OperationSetFileTransferSipImpl opSetFtSipImpl = null;
+
+	/**
+	 * The MSRP Message associated with this file transfer
+	 */
+	private msrp.Message associatedMessage = null;
+
+	/**
+	 * The MSRP Session associated with this file Transfer
+	 */
+	private Session session = null;
+
+	/**
+	 * boolean used to represent if this is an incoming file transfer or not
+	 */
+	private boolean isIncomingTransfer;
+
+	/**
+	 * the id used on the file-transfer-id attribute of the sdp offer
+	 */
+	private String fileTransferId;
+
+	/**
+	 * The list of uris that are used to deliver the file associated with this
+	 * file transfer
+	 */
+	private ArrayList<URI> toPath = null;
+
+	/**
+	 * The size of the file as described on the file-selector sdp attribute
+	 * 
+	 * Note: this field should only be used if this is an incoming FileTransfer
+	 */
+	private long size;
+
+	protected static Logger getLogger() {
+		return logger;
+	}
+
+	protected msrp.Message getAssociatedMessage() {
+		return associatedMessage;
+	}
+
+	protected Session getSession() {
+		return session;
+	}
+
+	protected String getFileTransferId() {
+		return fileTransferId;
+	}
+
+	/**
+	 * The name of the contact who will receive our file
+	 */
+	private String contactName = null;
+
+	/**
+	 * the name attribute received on the file-selector present on the SDP of
+	 * the received invite request manifesting an incoming request with a file
+	 * offer with a file whose name is defined by this field
+	 * 
+	 * Note: This field is only different from null if this is an incoming file
+	 * transfer
+	 */
+	private String fileName = null;
+
+	/**
+	 * The original invite Request containing the file request
+	 * 
+	 * Note: this field only get's filled when this file transfer is an incoming
+	 * one.
+	 */
+	private Request invite = null;
+
+	/**
+	 * The original invite transaction that contained the invite
+	 * 
+	 */
+	private javax.sip.Transaction inviteTransaction = null;
+
+	/**
+	 * Method used to create the FileTransferSipImpl object that represents a
+	 * SIP file transfer within SC
+	 * 
+	 * @param isIncomingTransfer
+	 *            boolean value true if this is an incoming transfer false
+	 *            otherwise
+	 * @param session
+	 *            the MSRP session associated with this SIP file transfer
+	 * @param message
+	 *            the MSRP message that wraps the file to be transfered
+	 * @param fileTransferId
+	 *            the file transfer id used on the file-transfer-id of the
+	 *            generated SDP offer.
+	 * @param fileName
+	 *            the String with the file name to be sent
+	 * @param contactName
+	 *            the string with the contact's display name to which this file
+	 *            transfer is meant
+	 * @param opSetFileTransfer
+	 *            the instance that created this File Transfer
+	 */
+
+	public FileTransferSipImpl(Session session, msrp.Message message,
+			String fileTransferId, javax.sip.Transaction transaction,
+			String fileName, String contactName,
+			OperationSetFileTransfer opSetFileTransfer) {
+		this.isIncomingTransfer = false;
+		this.session = session;
+		this.associatedMessage = message;
+		this.fileTransferId = fileTransferId;
+		this.inviteTransaction = transaction;
+		this.fileName = fileName;
+		this.contactName = contactName;
+		this.opSetFtSipImpl = (OperationSetFileTransferSipImpl) opSetFileTransfer;
+
+	}
+
+	/**
+	 * Constructor used to create a new sip file transfer.
+	 * 
+	 * This constructor is used upon the receipt of an invite and some of it's
+	 * parameters may be null depending on the SDP attached to the INVITE
+	 * 
+	 * @param toPath
+	 *            an ArrayList of URIs containing the future toPath of the
+	 *            future msrp session
+	 * @param fileTransferId
+	 *            the file-transfer-id attribute that should represent an unique
+	 *            file transfer
+	 * @param name
+	 *            the String with the name of the file if available or null
+	 *            otherwise
+	 * @param size
+	 *            the size of the file or zero if it doesn't exist
+	 * @param invite
+	 *            JAIN-SIP Request representing the invite of this offer
+	 * @param firstTransaction
+	 *            the Transaction associated with the new INVITE request
+	 * @param opSetFileTransfer
+	 *            the instance of the operation set that contains all of the
+	 *            operations needed to support file transfer for SIP
+	 * 
+	 */
+	public FileTransferSipImpl(ArrayList<URI> toPath, String fileTransferId,
+			String name, long size, Request invite,
+			javax.sip.Transaction firstTransaction,
+			OperationSetFileTransfer opSetFileTransfer) {
+		this.isIncomingTransfer = true;
+		this.toPath = toPath;
+		this.fileTransferId = fileTransferId;
+		this.fileName = name;
+		this.size = size;
+		this.invite = invite;
+		this.inviteTransaction = firstTransaction;
+		this.opSetFtSipImpl = (OperationSetFileTransferSipImpl) opSetFileTransfer;
+
+		ContactHeader contact = (ContactHeader) this.invite
+				.getHeader(javax.sip.header.ContactHeader.NAME);
+		this.contactName = contact.getAddress().getDisplayName();
+
+	}
+
+	/**
+	 * @return the CallID associated with the bounded transaction. This String
+	 *         uniquely identifies the call
+	 */
+	protected String getCallID() {
+		return inviteTransaction.getDialog().getCallId().getCallId();
+
+	}
+
+	/**
+	 * @return the toPath
+	 */
+	protected ArrayList<URI> getToPath() {
+		return toPath;
+	}
+
+	/**
+	 * @return the invite
+	 */
+	protected Request getInvite() {
+		return invite;
+	}
+
+	/**
+	 * 
+	 * @return the first transaction associated with the original invite
+	 */
+	protected javax.sip.Transaction getInviteTransaction() {
+		return inviteTransaction;
+	}
+
+	/**
+	 * Allows a user to accept an incoming file
+	 * 
+	 * @param file
+	 *            the File object that will contain the incoming file
+	 */
+	@Override
+	public void acceptFile(File file) {
+		try {
+			opSetFtSipImpl.acceptFile(file, this);
+		} catch (OperationFailedException e) {
+			logger.error("accept file on file: " + file.getName() + " failed.",
+					e);
+			cancelFile();
+		}
+	}
+
+	@Override
+	public void cancelFile() {
+		// TODO yet to be done
+
+	}
+
+	@Override
+	public String getContactName() {
+		return contactName;
+	}
+
+	@Override
+	public String getFileName() {
+		return fileName;
+	}
+
+	@Override
+	public long getFileSize() {
+		return size;
+	}
+
+	@Override
+	public long getId() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public boolean iAmTheSender() {
+		return !isIncomingTransfer;
+	}
+
+	@Override
+	public void refuseFile() {
+		// TODO Issue #3 
+
+	}
+
+	/**
+	 * This method stores a reference to the Session that represents the
+	 * FileTransfer
+	 * 
+	 * @param session the session to be associated with this file transfer
+	 */
+	protected void setAssociatedSession(msrp.Session session) 
+	{
+		this.session = session;
+	}
+	/**
+	 * This method stores a reference to the Message that represents the
+	 * FileTransfer
+	 * 
+	 * @param message the message associated with this File Transfer
+	 */
+	protected void setAssociatedMessage(msrp.Message message) 
+	{
+		this.associatedMessage = message;
+	}
+
+	/**
+	 * releases all of the resources that are occupied by this FileTransfer
+	 * includes MSRP Sessions/Messages/ Closing File streams, etc.
+	 */
+	public void releaseResources() {
+		session.tearDown();
+		associatedMessage.getDataContainer().dispose();
+		
+
+	}
+
+}
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/security/MessageDigestAlgorithm.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/security/MessageDigestAlgorithm.java	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/security/MessageDigestAlgorithm.java	(revision 4319)
@@ -18,8 +18,10 @@
 
 public class MessageDigestAlgorithm
 {
-    private static final  Logger logger
-        = Logger.getLogger(MessageDigestAlgorithm.class);
+	//FIXME log messages temporarily turned off
+//    private static final  Logger logger
+//        = Logger.getLogger(MessageDigestAlgorithm.class);
+	static DummyLogger logger = new DummyLogger();
 
     /**
      * Calculates an http authentication response in accordance with rfc2617.
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/security/SipSecurityManager.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/security/SipSecurityManager.java	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/security/SipSecurityManager.java	(revision 4319)
@@ -30,8 +30,10 @@
 
 public class SipSecurityManager
 {
-    private static final Logger logger
-        = Logger.getLogger(SipSecurityManager.class);
+	//FIXME log temporarily turned off
+//    private static final Logger logger
+//        = Logger.getLogger(SipSecurityManager.class);
+	DummyLogger logger = new DummyLogger();
 
     /**
      * The SecurityAuthority instance that we could use to obtain new passwords
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/ProtocolProviderServiceSipImpl.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/ProtocolProviderServiceSipImpl.java	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/ProtocolProviderServiceSipImpl.java	(revision 4319)
@@ -1,8 +1,7 @@
 /*
  * SIP Communicator, the OpenSource Java VoIP and Instant Messaging client.
- *
- * Distributable under LGPL license.
- * See terms of license at gnu.org.
+ * 
+ * Distributable under LGPL license. See terms of license at gnu.org.
  */
 package net.java.sip.communicator.impl.protocol.sip;
 
@@ -26,2407 +25,2249 @@
 
 /**
  * A SIP implementation of the Protocol Provider Service.
- *
+ * 
  * @author Emil Ivov
  */
-public class ProtocolProviderServiceSipImpl
-  implements ProtocolProviderService, SipListener
-{
-    private static final Logger logger =
-        Logger.getLogger(ProtocolProviderServiceSipImpl.class);
+public class ProtocolProviderServiceSipImpl implements ProtocolProviderService,
+		SipListener {
+	//FIXME logger use temporarily turned off
+	//private static final Logger logger = Logger
+	//		.getLogger(ProtocolProviderServiceSipImpl.class);
+	DummyLogger logger=new DummyLogger();
 
-    /**
-     * The hashtable with the operation sets that we support locally.
-     */
-    private Hashtable supportedOperationSets = new Hashtable();
+	/**
+	 * The hashtable with the operation sets that we support locally.
+	 */
+	private Hashtable supportedOperationSets = new Hashtable();
 
-    /**
-     * The identifier of the account that this provider represents.
-     */
-    private AccountID accountID = null;
+	/**
+	 * The identifier of the account that this provider represents.
+	 */
+	private AccountID accountID = null;
 
-    /**
-     * We use this to lock access to initialization.
-     */
-    private Object initializationLock = new Object();
+	/**
+	 * We use this to lock access to initialization.
+	 */
+	private Object initializationLock = new Object();
 
-    /**
-     * indicates whether or not the provider is initialized and ready for use.
-     */
-    private boolean isInitialized = false;
+	/**
+	 * indicates whether or not the provider is initialized and ready for use.
+	 */
+	private boolean isInitialized = false;
 
-    /**
-     * A list of all listeners registered for
-     * <tt>RegistrationStateChangeEvent</tt>s.
-     */
-    private List registrationListeners = new ArrayList();
+	/**
+	 * A list of all listeners registered for
+	 * <tt>RegistrationStateChangeEvent</tt>s.
+	 */
+	private List registrationListeners = new ArrayList();
 
-    /**
-     * A list of all events registered for this provider.
-     */
-    private List registeredEvents = new ArrayList();
+	/**
+	 * A list of all events registered for this provider.
+	 */
+	private List registeredEvents = new ArrayList();
 
-    /**
-     * The SipFactory instance used to create the SipStack and the Address
-     * Message and Header Factories.
-     */
-    private SipFactory sipFactory;
+	/**
+	 * The SipFactory instance used to create the SipStack and the Address
+	 * Message and Header Factories.
+	 */
+	private SipFactory sipFactory;
 
-    /**
-     * The AddressFactory used to create URLs ans Address objects.
-     */
-    private AddressFactory addressFactory;
+	/**
+	 * The AddressFactory used to create URLs ans Address objects.
+	 */
+	private AddressFactory addressFactory;
 
-    /**
-     * The HeaderFactory used to create SIP message headers.
-     */
-    private HeaderFactory headerFactory;
+	/**
+	 * The HeaderFactory used to create SIP message headers.
+	 */
+	private HeaderFactory headerFactory;
 
-    /**
-     * The Message Factory used to create SIP messages.
-     */
-    private MessageFactory messageFactory;
+	/**
+	 * The Message Factory used to create SIP messages.
+	 */
+	private MessageFactory messageFactory;
 
-    /**
-     * The sipStack instance that handles SIP communications.
-     */
-    private SipStack jainSipStack;
+	/**
+	 * The sipStack instance that handles SIP communications.
+	 */
+	private SipStack jainSipStack;
 
-    /**
-     * The properties of the jainSipStack.
-     */
-    private Properties jainSipStackProperties;
+	/**
+	 * The properties of the jainSipStack.
+	 */
+	private Properties jainSipStackProperties;
 
-    /**
-     * The default listening point that we use for UDP communication..
-     */
-    private ListeningPoint udpListeningPoint = null;
+	/**
+	 * The default listening point that we use for UDP communication..
+	 */
+	private ListeningPoint udpListeningPoint = null;
 
-    /**
-     * The default listening point that we use for TCP communication..
-     */
-    private ListeningPoint tcpListeningPoint = null;
+	/**
+	 * The default listening point that we use for TCP communication..
+	 */
+	private ListeningPoint tcpListeningPoint = null;
 
-    /**
-     * The default listening point that we use for TLS communication..
-     */
-    private ListeningPoint tlsListeningPoint = null;
+	/**
+	 * The default listening point that we use for TLS communication..
+	 */
+	private ListeningPoint tlsListeningPoint = null;
 
-    /**
-     * The default JAIN SIP provider that we use for UDP communication...
-     */
-    private SipProvider udpJainSipProvider = null;
+	/**
+	 * The default JAIN SIP provider that we use for UDP communication...
+	 */
+	private SipProvider udpJainSipProvider = null;
 
-    /**
-     * The default JAIN SIP provider that we use for TCP communication...
-     */
-    private SipProvider tcpJainSipProvider = null;
+	/**
+	 * The default JAIN SIP provider that we use for TCP communication...
+	 */
+	private SipProvider tcpJainSipProvider = null;
 
-    /**
-     * The default JAIN SIP provider that we use for TLS communication...
-     */
-    private SipProvider tlsJainSipProvider = null;
+	/**
+	 * The default JAIN SIP provider that we use for TLS communication...
+	 */
+	private SipProvider tlsJainSipProvider = null;
 
-    /**
-     * A table mapping SIP methods to method processors (every processor must
-     * implement the SipListener interface). Whenever a new message arrives we
-     * extract its method and hand it to the processor instance registered
-     */
-    private Hashtable methodProcessors = new Hashtable();
+	/**
+	 * A table mapping SIP methods to method processors (every processor must
+	 * implement the SipListener interface). Whenever a new message arrives we
+	 * extract its method and hand it to the processor instance registered
+	 */
+	private Hashtable<String, List<SipListener>> methodProcessors = new Hashtable<String, List<SipListener>>();
 
-    /**
-     * The name of the property under which the jain-sip-ri would expect to find
-     * the address, port and transport.
-     */
-    private static final String JSPNAME_OUTBOUND_PROXY =
-        "javax.sip.OUTBOUND_PROXY";
+	/**
+	 * The name of the property under which the jain-sip-ri would expect to find
+	 * the address, port and transport.
+	 */
+	private static final String JSPNAME_OUTBOUND_PROXY = "javax.sip.OUTBOUND_PROXY";
 
-    /**
-     * The name of the property under which the jain-sip-ri would expect to find
-     * the the name of the stack..
-     */
-    private static final String JSPNAME_STACK_NAME =
-        "javax.sip.STACK_NAME";
-    /**
-     * The name of the property under which the jain-sip-ri would expect to find
-     * the name of a debug log file.
-     */
-    private static final String NSPNAME_DEBUG_LOG =
-        "gov.nist.javax.sip.DEBUG_LOG";
+	/**
+	 * The name of the property under which the jain-sip-ri would expect to find
+	 * the the name of the stack..
+	 */
+	private static final String JSPNAME_STACK_NAME = "javax.sip.STACK_NAME";
 
-    /**
-     * The default name of a debug log file for the jain-sip RI.
-     */
-    private static String NSPVALUE_DEBUG_LOG = "log/sc-jainsipdebug.log";
+	/**
+	 * The name of the property under which the jain-sip-ri would expect to find
+	 * the name of a debug log file.
+	 */
+	private static final String NSPNAME_DEBUG_LOG = "gov.nist.javax.sip.DEBUG_LOG";
 
-    /**
-     * The name of the property under which the jain-sip-ri would expect to find
-     * the name of a server log file (I don't really know what is the
-     * difference between this and the DEBUG_LOG).
-     */
-    private static final String NSPNAME_SERVER_LOG =
-        "gov.nist.javax.sip.SERVER_LOG";
+	/**
+	 * The default name of a debug log file for the jain-sip RI.
+	 */
+	private static String NSPVALUE_DEBUG_LOG = "log/sc-jainsipdebug.log";
 
-    /**
-     * The default name of a server log file for the jain-sip RI.
-     */
-    private static String NSPVALUE_SERVER_LOG  = "log/sc-jainsipserver.log";
+	/**
+	 * The name of the property under which the jain-sip-ri would expect to find
+	 * the name of a server log file (I don't really know what is the difference
+	 * between this and the DEBUG_LOG).
+	 */
+	private static final String NSPNAME_SERVER_LOG = "gov.nist.javax.sip.SERVER_LOG";
 
-    /**
-     * The name of the property under which jain-sip will know if it must
-     * deliver some unsolicited notify.
-     */
-    private static final String NSPNAME_DELIVER_UNSOLICITED_NOTIFY =
-        "gov.nist.javax.sip.DELIVER_UNSOLICITED_NOTIFY";
+	/**
+	 * The default name of a server log file for the jain-sip RI.
+	 */
+	private static String NSPVALUE_SERVER_LOG = "log/sc-jainsipserver.log";
 
-    /**
-     * The value of the property under which jain-sip will know if it must
-     * deliver some unsolicited notify.
-     */
-    private static final String NSPVALUE_DELIVER_UNSOLICITED_NOTIFY = "true";
+	/**
+	 * The name of the property under which jain-sip will know if it must
+	 * deliver some unsolicited notify.
+	 */
+	private static final String NSPNAME_DELIVER_UNSOLICITED_NOTIFY = "gov.nist.javax.sip.DELIVER_UNSOLICITED_NOTIFY";
 
-    /**
-     * A random generator we use to generate tags.
-     */
-    private static Random localTagGenerator = new Random();
+	/**
+	 * The value of the property under which jain-sip will know if it must
+	 * deliver some unsolicited notify.
+	 */
+	private static final String NSPVALUE_DELIVER_UNSOLICITED_NOTIFY = "true";
 
-    /**
-     * The name of the property under which the jain-sip-ri would expect to find
-     * the log level (detail) for all stack logging.
-     */
-    private static final String NSPNAME_TRACE_LEVEL =
-        "gov.nist.javax.sip.TRACE_LEVEL";
+	/**
+	 * A random generator we use to generate tags.
+	 */
+	private static Random localTagGenerator = new Random();
 
-    /**
-     * A String indicating the default debug level for the jain-sip-ri (must be
-     * log4j compatible).
-     */
-    private static final String NSPVALUE_TRACE_LEVEL = "DEBUG";
+	/**
+	 * The name of the property under which the jain-sip-ri would expect to find
+	 * the log level (detail) for all stack logging.
+	 */
+	private static final String NSPNAME_TRACE_LEVEL = "gov.nist.javax.sip.TRACE_LEVEL";
 
-    /**
-     * The name of the property under which the jain-sip-ri would expect to find
-     * a property specifying whether or not it is to cache client connections.
-     */
-    private static final String NSPNAME_CACHE_CLIENT_CONNECTIONS =
-        "gov.nist.javax.sip.CACHE_CLIENT_CONNECTIONS";
+	/**
+	 * A String indicating the default debug level for the jain-sip-ri (must be
+	 * log4j compatible).
+	 */
+	private static final String NSPVALUE_TRACE_LEVEL = "DEBUG";
 
-    /**
-     * The name of the property under which the user may specify the number of
-     * the port where they would prefer us to bind our sip socket.
-     */
-    private static final String PREFERRED_SIP_PORT =
-        "net.java.sip.communicator.service.protocol.sip.PREFERRED_SIP_PORT";
+	/**
+	 * The name of the property under which the jain-sip-ri would expect to find
+	 * a property specifying whether or not it is to cache client connections.
+	 */
+	private static final String NSPNAME_CACHE_CLIENT_CONNECTIONS = "gov.nist.javax.sip.CACHE_CLIENT_CONNECTIONS";
 
+	/**
+	 * The name of the property under which the user may specify the number of
+	 * the port where they would prefer us to bind our sip socket.
+	 */
+	private static final String PREFERRED_SIP_PORT = "net.java.sip.communicator.service.protocol.sip.PREFERRED_SIP_PORT";
 
-    /**
-     * The name of the property under which the user may specify the number of
-     * seconds that registrations take to expire.
-     */
-    private static final String REGISTRATION_EXPIRATION =
-        "net.java.sip.communicator.impl.protocol.sip.REGISTRATION_EXPIRATION";
-    
-    /**
-     * The name of the property under which the user may specify whether or not
-     * REGISTER requests should be using a route header. Default is false
-     */
-    private static final String REGISTERS_USE_ROUTE =
-        "net.java.sip.communicator.impl.protocol.sip.REGISTERS_USE_ROUTE";
+	/**
+	 * The name of the property under which the user may specify the number of
+	 * seconds that registrations take to expire.
+	 */
+	private static final String REGISTRATION_EXPIRATION = "net.java.sip.communicator.impl.protocol.sip.REGISTRATION_EXPIRATION";
 
-    /**
-     * A default specifyier telling the stack whether or not to cache client
-     * connections.
-     */
-    private static final String NSPVALUE_CACHE_CLIENT_CONNECTIONS = "true";
+	/**
+	 * The name of the property under which the user may specify whether or not
+	 * REGISTER requests should be using a route header. Default is false
+	 */
+	private static final String REGISTERS_USE_ROUTE = "net.java.sip.communicator.impl.protocol.sip.REGISTERS_USE_ROUTE";
 
-    /**
-     * The name of the property under which the user may specify a transport
-     * to use for destinations whose prefererred transport is unknown.
-     */
-    private static final String DEFAULT_TRANSPORT
-        = "net.java.sip.communicator.impl.protocol.sip.DEFAULT_TRANSPORT";
+	/**
+	 * A default specifyier telling the stack whether or not to cache client
+	 * connections.
+	 */
+	private static final String NSPVALUE_CACHE_CLIENT_CONNECTIONS = "true";
 
-    /**
-     * Default number of times that our requests can be forwarded.
-     */
-    private static final int  MAX_FORWARDS = 70;
-    
-    /**
-     * Keep-alive method can be - register,options or udp 
-     */
-    public static final String KEEP_ALIVE_METHOD = "KEEP_ALIVE_METHOD";
-    
-    /**
-     * The interval for keep-alive
-     */
-    public static final String KEEP_ALIVE_INTERVAL = "KEEP_ALIVE_INTERVAL";
+	/**
+	 * The name of the property under which the user may specify a transport to
+	 * use for destinations whose prefererred transport is unknown.
+	 */
+	private static final String DEFAULT_TRANSPORT = "net.java.sip.communicator.impl.protocol.sip.DEFAULT_TRANSPORT";
 
-    /**
-     * The default maxForwards header that we use in our requests.
-     */
-    private MaxForwardsHeader maxForwardsHeader = null;
+	/**
+	 * Default number of times that our requests can be forwarded.
+	 */
+	private static final int MAX_FORWARDS = 70;
 
-    /**
-     * The contact header we use in non REGISTER requests.
-     */
-    private ContactHeader genericContactHeader = null;
+	/**
+	 * Keep-alive method can be - register,options or udp
+	 */
+	public static final String KEEP_ALIVE_METHOD = "KEEP_ALIVE_METHOD";
 
-    /**
-     * The header that we use to identify ourselves.
-     */
-    private UserAgentHeader userAgentHeader = null;
+	/**
+	 * The interval for keep-alive
+	 */
+	public static final String KEEP_ALIVE_INTERVAL = "KEEP_ALIVE_INTERVAL";
 
-    /**
-     * The sip address that we're currently behind (the one that corresponds to
-     * our account id).
-     */
-    private Address ourSipAddress = null;
+	/**
+	 * The default maxForwards header that we use in our requests.
+	 */
+	private MaxForwardsHeader maxForwardsHeader = null;
 
-    /**
-     * The name that we want to send others when calling or chatting with them.
-     */
-    private String ourDisplayName = null;
+	/**
+	 * The contact header we use in non REGISTER requests.
+	 */
+	private ContactHeader genericContactHeader = null;
 
-    /**
-     * Our current connection with the registrar.
-     */
-    private SipRegistrarConnection sipRegistrarConnection = null;
+	/**
+	 * The header that we use to identify ourselves.
+	 */
+	private UserAgentHeader userAgentHeader = null;
 
-    /**
-     * The SipSecurityManager instance that would be taking care of our
-     * authentications.
-     */
-    private SipSecurityManager sipSecurityManager = null;
+	/**
+	 * The sip address that we're currently behind (the one that corresponds to
+	 * our account id).
+	 */
+	private Address ourSipAddress = null;
 
-    /**
-     * The address and port of an outbound proxy if we have one (remains null
-     * if we are not using a proxy).
-     */
-    private InetSocketAddress outboundProxySocketAddress = null;
+	/**
+	 * The name that we want to send others when calling or chatting with them.
+	 */
+	private String ourDisplayName = null;
 
-    /**
-     * The transport used by our outbound proxy (remains null
-     * if we are not using a proxy).
-     */
-    private String outboundProxyTransport = null;
+	/**
+	 * Our current connection with the registrar.
+	 */
+	private SipRegistrarConnection sipRegistrarConnection = null;
 
-    /**
-     * The logo corresponding to the jabber protocol.
-     */
-    private ProtocolIconSipImpl protocolIcon;
+	/**
+	 * The SipSecurityManager instance that would be taking care of our
+	 * authentications.
+	 */
+	private SipSecurityManager sipSecurityManager = null;
 
-    private SipStatusEnum sipStatusEnum;
+	/**
+	 * The address and port of an outbound proxy if we have one (remains null if
+	 * we are not using a proxy).
+	 */
+	private InetSocketAddress outboundProxySocketAddress = null;
 
-    /**
-     * Registers the specified listener with this provider so that it would
-     * receive notifications on changes of its state or other properties such
-     * as its local address and display name.
-     * @param listener the listener to register.
-     */
-    public void addRegistrationStateChangeListener(
-        RegistrationStateChangeListener listener)
-    {
-        synchronized(registrationListeners)
-        {
-            if (!registrationListeners.contains(listener))
-                registrationListeners.add(listener);
-        }
-    }
+	/**
+	 * The transport used by our outbound proxy (remains null if we are not
+	 * using a proxy).
+	 */
+	private String outboundProxyTransport = null;
 
-    /**
-     * Creates a RegistrationStateChange event corresponding to the specified
-     * old and new jain sip states and notifies all currently registered
-     * listeners.
-     * <p>
-     * @param oldState the state that we had before this transition occurred.
-     * @param newState the state that we have now after the transition has
-     * occurred
-     * @param reasonCode a code indicating the reason for the event.
-     * @param reason a text explaining the reason for the event.
-     */
-     public void fireRegistrationStateChanged( RegistrationState oldState,
-                                               RegistrationState newState,
-                                               int               reasonCode,
-                                               String            reason )
-    {
-        RegistrationStateChangeEvent event
-            = new RegistrationStateChangeEvent(
-                this, oldState, newState, reasonCode, reason);
+	/**
+	 * The logo corresponding to the jabber protocol.
+	 */
+	private ProtocolIconSipImpl protocolIcon;
 
-        logger.debug("Dispatching " + event + " to "
-                     + registrationListeners.size()+ " listeners.");
+	private SipStatusEnum sipStatusEnum;
 
-        Iterator listeners = null;
-        synchronized (registrationListeners)
-        {
-            listeners = new ArrayList(registrationListeners).iterator();
-        }
+	/**
+	 * Registers the specified listener with this provider so that it would
+	 * receive notifications on changes of its state or other properties such as
+	 * its local address and display name.
+	 * 
+	 * @param listener
+	 *            the listener to register.
+	 */
+	public void addRegistrationStateChangeListener(
+			RegistrationStateChangeListener listener) {
+		synchronized (registrationListeners) {
+			if (!registrationListeners.contains(listener))
+				registrationListeners.add(listener);
+		}
+	}
 
-        while (listeners.hasNext())
-        {
-            RegistrationStateChangeListener listener
-                = (RegistrationStateChangeListener) listeners.next();
+	/**
+	 * Creates a RegistrationStateChange event corresponding to the specified
+	 * old and new jain sip states and notifies all currently registered
+	 * listeners.
+	 * <p>
+	 * 
+	 * @param oldState
+	 *            the state that we had before this transition occurred.
+	 * @param newState
+	 *            the state that we have now after the transition has occurred
+	 * @param reasonCode
+	 *            a code indicating the reason for the event.
+	 * @param reason
+	 *            a text explaining the reason for the event.
+	 */
+	public void fireRegistrationStateChanged(RegistrationState oldState,
+			RegistrationState newState, int reasonCode, String reason) {
+		RegistrationStateChangeEvent event = new RegistrationStateChangeEvent(
+				this, oldState, newState, reasonCode, reason);
 
-            listener.registrationStateChanged(event);
-        }
+		logger.debug("Dispatching " + event + " to "
+				+ registrationListeners.size() + " listeners.");
 
-        logger.trace("Done.");
-    }
+		Iterator listeners = null;
+		synchronized (registrationListeners) {
+			listeners = new ArrayList(registrationListeners).iterator();
+		}
 
-    /**
-     * Returns the AccountID that uniquely identifies the account represented by
-     * this instance of the ProtocolProviderService.
-     * @return the id of the account represented by this provider.
-     */
-    public AccountID getAccountID()
-    {
-        return accountID;
-    }
+		while (listeners.hasNext()) {
+			RegistrationStateChangeListener listener = (RegistrationStateChangeListener) listeners
+					.next();
 
-    /**
-     * Returns the state of the registration of this protocol provider with the
-     * corresponding registration service.
-     * @return ProviderRegistrationState
-     */
-    public RegistrationState getRegistrationState()
-    {
-        if(this.sipRegistrarConnection == null )
-        {
-            return RegistrationState.UNREGISTERED;
-        }
-        return sipRegistrarConnection.getRegistrationState();
-    }
+			listener.registrationStateChanged(event);
+		}
 
-    /**
-     * Returns the short name of the protocol that the implementation of this
-     * provider is based upon (like SIP, Jabber, ICQ/AIM,  or others for
-     * example). If the name of the protocol has been enumerated in
-     * ProtocolNames then the value returned by this method must be the same as
-     * the one in ProtocolNames.
-     * @return a String containing the short name of the protocol this service
-     * is implementing (most often that would be a name in ProtocolNames).
-     */
-    public String getProtocolName()
-    {
-        return ProtocolNames.SIP;
-    }
+		logger.trace("Done.");
+	}
 
-    /**
-     * Returns the protocol display name. This is the name that would be used
-     * by the GUI to display the protocol name.
-     * 
-     * @return a String containing the display name of the protocol this service
-     * is implementing
-     */
-    public String getProtocolDisplayName()
-    {
-        return (String) accountID.getAccountProperties()
-            .get(ProtocolProviderFactory.PROTOCOL);
-    }
+	/**
+	 * Returns the AccountID that uniquely identifies the account represented by
+	 * this instance of the ProtocolProviderService.
+	 * 
+	 * @return the id of the account represented by this provider.
+	 */
+	public AccountID getAccountID() {
+		return accountID;
+	}
 
-    /**
-     * Register a new event taken in account by this provider. This is usefull
-     * to generate the Allow-Events header of the OPTIONS responses and to
-     * generate 489 responses.
-     *
-     * @param event The event to register
-     */
-    public void registerEvent(String event) {
-        synchronized (this.registeredEvents) {
-            if (!this.registeredEvents.contains(event)) {
-                this.registeredEvents.add(event);
-            }
-        }
-    }
+	/**
+	 * Returns the state of the registration of this protocol provider with the
+	 * corresponding registration service.
+	 * 
+	 * @return ProviderRegistrationState
+	 */
+	public RegistrationState getRegistrationState() {
+		if (this.sipRegistrarConnection == null) {
+			return RegistrationState.UNREGISTERED;
+		}
+		return sipRegistrarConnection.getRegistrationState();
+	}
 
-    /**
-     * Returns the list of all the registered events for this provider.
-     *
-     * @return The list of all the registered events
-     */
-    public List getKnownEventsList() {
-        return this.registeredEvents;
-    }
+	/**
+	 * Returns the short name of the protocol that the implementation of this
+	 * provider is based upon (like SIP, Jabber, ICQ/AIM, or others for
+	 * example). If the name of the protocol has been enumerated in
+	 * ProtocolNames then the value returned by this method must be the same as
+	 * the one in ProtocolNames.
+	 * 
+	 * @return a String containing the short name of the protocol this service
+	 *         is implementing (most often that would be a name in
+	 *         ProtocolNames).
+	 */
+	public String getProtocolName() {
+		return ProtocolNames.SIP;
+	}
 
-    /**
-     * Indicates whether or not this provider is registered
-     * @return true if the provider is currently registered and false otherwise.
-     */
-    public boolean isRegistered()
-    {
-        if(this.sipRegistrarConnection == null )
-        {
-            return false;
-        }
-        return sipRegistrarConnection.getRegistrationState()
-            .equals(RegistrationState.REGISTERED);
-    }
+	/**
+	 * Returns the protocol display name. This is the name that would be used by
+	 * the GUI to display the protocol name.
+	 * 
+	 * @return a String containing the display name of the protocol this service
+	 *         is implementing
+	 */
+	public String getProtocolDisplayName() {
+		return (String) accountID.getAccountProperties().get(
+				ProtocolProviderFactory.PROTOCOL);
+	}
 
-    /**
-     * Removes the specified listener.
-     * @param listener the listener to remove.
-     */
-    public void removeRegistrationStateChangeListener(
-        RegistrationStateChangeListener listener)
-    {
-        synchronized(registrationListeners)
-        {
-            this.registrationListeners.remove(listener);
-        }
-    }
+	/**
+	 * Register a new event taken in account by this provider. This is usefull
+	 * to generate the Allow-Events header of the OPTIONS responses and to
+	 * generate 489 responses.
+	 * 
+	 * @param event
+	 *            The event to register
+	 */
+	public void registerEvent(String event) {
+		synchronized (this.registeredEvents) {
+			if (!this.registeredEvents.contains(event)) {
+				this.registeredEvents.add(event);
+			}
+		}
+	}
 
-    /**
-     * Returns an array containing all operation sets supported by the current
-     * implementation. When querying this method users must be prepared to
-     * receive any sybset of the OperationSet-s defined by this service. They
-     * MUST ignore any OperationSet-s that they are not aware of and that may be
-     * defined by future version of this service. Such "unknown" OperationSet-s
-     * though not encouraged, may also be defined by service implementors.
-     *
-     * @return a java.util.Map containing instance of all supported operation
-     * sets mapped against their class names (e.g.
-     * OperationSetPresence.class.getName()) .
-     */
-    public Map getSupportedOperationSets()
-    {
-        return supportedOperationSets;
-    }
+	/**
+	 * Returns the list of all the registered events for this provider.
+	 * 
+	 * @return The list of all the registered events
+	 */
+	public List getKnownEventsList() {
+		return this.registeredEvents;
+	}
 
-    /**
-     * Returns the operation set corresponding to the specified class or null
-     * if this operation set is not supported by the provider implementation.
-     *
-     * @param opsetClass the <tt>Class</tt>  of the operation set that we're
-     * looking for.
-     * @return returns an OperationSet of the specified <tt>Class</tt> if the
-     * undelying implementation supports it or null otherwise.
-     */
-    public OperationSet getOperationSet(Class opsetClass)
-    {
-        return (OperationSet)getSupportedOperationSets()
-            .get(opsetClass.getName());
-    }
+	/**
+	 * Indicates whether or not this provider is registered
+	 * 
+	 * @return true if the provider is currently registered and false otherwise.
+	 */
+	public boolean isRegistered() {
+		if (this.sipRegistrarConnection == null) {
+			return false;
+		}
+		return sipRegistrarConnection.getRegistrationState().equals(
+				RegistrationState.REGISTERED);
+	}
 
+	/**
+	 * Removes the specified listener.
+	 * 
+	 * @param listener
+	 *            the listener to remove.
+	 */
+	public void removeRegistrationStateChangeListener(
+			RegistrationStateChangeListener listener) {
+		synchronized (registrationListeners) {
+			this.registrationListeners.remove(listener);
+		}
+	}
 
+	/**
+	 * Returns an array containing all operation sets supported by the current
+	 * implementation. When querying this method users must be prepared to
+	 * receive any sybset of the OperationSet-s defined by this service. They
+	 * MUST ignore any OperationSet-s that they are not aware of and that may be
+	 * defined by future version of this service. Such "unknown" OperationSet-s
+	 * though not encouraged, may also be defined by service implementors.
+	 * 
+	 * @return a java.util.Map containing instance of all supported operation
+	 *         sets mapped against their class names (e.g.
+	 *         OperationSetPresence.class.getName()) .
+	 */
+	public Map getSupportedOperationSets() {
+		return supportedOperationSets;
+	}
 
-    /**
-     * Starts the registration process. Connection details such as
-     * registration server, user name/number are provided through the
-     * configuration service through implementation specific properties.
-     *
-     * @param authority the security authority that will be used for resolving
-     *        any security challenges that may be returned during the
-     *        registration or at any moment while wer're registered.
-     *
-     * @throws OperationFailedException with the corresponding code it the
-     * registration fails for some reason (e.g. a networking error or an
-     * implementation problem).
+	/**
+	 * Returns the operation set corresponding to the specified class or null if
+	 * this operation set is not supported by the provider implementation.
+	 * 
+	 * @param opsetClass
+	 *            the <tt>Class</tt> of the operation set that we're looking
+	 *            for.
+	 * @return returns an OperationSet of the specified <tt>Class</tt> if the
+	 *         undelying implementation supports it or null otherwise.
+	 */
+	public OperationSet getOperationSet(Class opsetClass) {
+		return (OperationSet) getSupportedOperationSets().get(
+				opsetClass.getName());
+	}
 
-     */
-    public void register(SecurityAuthority authority)
-        throws OperationFailedException
-    {
-        if(!isInitialized)
-        {
-            throw new OperationFailedException(
-                "Provided must be initialized before being able to register."
-                , OperationFailedException.GENERAL_ERROR);
-        }
+	/**
+	 * Starts the registration process. Connection details such as registration
+	 * server, user name/number are provided through the configuration service
+	 * through implementation specific properties.
+	 * 
+	 * @param authority
+	 *            the security authority that will be used for resolving any
+	 *            security challenges that may be returned during the
+	 *            registration or at any moment while wer're registered.
+	 * 
+	 * @throws OperationFailedException
+	 *             with the corresponding code it the registration fails for
+	 *             some reason (e.g. a networking error or an implementation
+	 *             problem).
+	 */
+	public void register(SecurityAuthority authority)
+			throws OperationFailedException {
+		if (!isInitialized) {
+			throw new OperationFailedException(
+					"Provided must be initialized before being able to register.",
+					OperationFailedException.GENERAL_ERROR);
+		}
 
-        if (isRegistered())
-        {
-            return;
-        }
+		if (isRegistered()) {
+			return;
+		}
 
-        // Enable the user name modification. Setting this property to true we'll
-        // allow the user to change the user name stored in the given authority.
-        authority.setUserNameEditable(true);
+		// Enable the user name modification. Setting this property to true
+		// we'll
+		// allow the user to change the user name stored in the given authority.
+		authority.setUserNameEditable(true);
 
-        //init the security manager before doing the actual registration to
-        //avoid being asked for credentials before being ready to provide them
-        sipSecurityManager.setSecurityAuthority(authority);
+		// init the security manager before doing the actual registration to
+		// avoid being asked for credentials before being ready to provide them
+		sipSecurityManager.setSecurityAuthority(authority);
 
-        // We check here if the sipRegistrarConnection is initialized. This is
-        // needed in case that in the initialization process we had no internet
-        // connection.
-        if (sipRegistrarConnection == null)
-            initRegistrarConnection((SipAccountID) accountID);
+		// We check here if the sipRegistrarConnection is initialized. This is
+		// needed in case that in the initialization process we had no internet
+		// connection.
+		if (sipRegistrarConnection == null)
+			initRegistrarConnection((SipAccountID) accountID);
 
-        // The same here, we check if the outbound proxy is initialized in case
-        // through the initialization process there was no internet connection.
-        if (outboundProxySocketAddress == null)
-            initOutboundProxy((SipAccountID)accountID, jainSipStackProperties);
+		// The same here, we check if the outbound proxy is initialized in case
+		// through the initialization process there was no internet connection.
+		if (outboundProxySocketAddress == null)
+			initOutboundProxy((SipAccountID) accountID, jainSipStackProperties);
 
-        //connect to the Registrar.
-        if (sipRegistrarConnection != null)
-            sipRegistrarConnection.register();
-    }
+		// connect to the Registrar.
+		if (sipRegistrarConnection != null)
+			sipRegistrarConnection.register();
+	}
 
-    /**
-     * Ends the registration of this protocol provider with the current
-     * registration service.
-     *
-     * @throws OperationFailedException with the corresponding code it the
-     * registration fails for some reason (e.g. a networking error or an
-     * implementation problem).
-     */
-    public void unregister()
-        throws OperationFailedException
-    {
-        if(getRegistrationState().equals(RegistrationState.UNREGISTERED)
-            || getRegistrationState().equals(RegistrationState.UNREGISTERING))
-        {
-            return;
-        }
+	/**
+	 * Ends the registration of this protocol provider with the current
+	 * registration service.
+	 * 
+	 * @throws OperationFailedException
+	 *             with the corresponding code it the registration fails for
+	 *             some reason (e.g. a networking error or an implementation
+	 *             problem).
+	 */
+	public void unregister() throws OperationFailedException {
+		if (getRegistrationState().equals(RegistrationState.UNREGISTERED)
+				|| getRegistrationState().equals(
+						RegistrationState.UNREGISTERING)) {
+			return;
+		}
 
-        sipRegistrarConnection.unregister();
-        sipSecurityManager.setSecurityAuthority(null);
-    }
+		sipRegistrarConnection.unregister();
+		sipSecurityManager.setSecurityAuthority(null);
+	}
 
-    /**
-     * Initializes the service implementation, and puts it in a state where it
-     * could interoperate with other services.
-     *
-     * @param sipAddress the account id/uin/screenname of the account that we're
-     * about to create
-     * @param accountID the identifier of the account that this protocol
-     * provider represents.
-     * @param isInstall indicates if this initialization is made due to a new
-     * account installation or just an existing account loading
-     * 
-     * @throws OperationFailedException with code INTERNAL_ERROR if we fail
-     * initializing the SIP Stack.
-     * @throws java.lang.IllegalArgumentException if one or more of the account
-     * properties have invalid values.
-     *
-     * @see net.java.sip.communicator.service.protocol.AccountID
-     */
-    protected void initialize(String    sipAddress,
-                              SipAccountID accountID)
-        throws OperationFailedException, IllegalArgumentException
-    {
-        synchronized (initializationLock)
-        {
-            String logDir
-                = SipActivator.getConfigurationService().getScHomeDirLocation()
-                + System.getProperty("file.separator")
-                + SipActivator.getConfigurationService().getScHomeDirName()
-                + System.getProperty("file.separator");
+	/**
+	 * Initializes the service implementation, and puts it in a state where it
+	 * could interoperate with other services.
+	 * 
+	 * @param sipAddress
+	 *            the account id/uin/screenname of the account that we're about
+	 *            to create
+	 * @param accountID
+	 *            the identifier of the account that this protocol provider
+	 *            represents.
+	 * @param isInstall
+	 *            indicates if this initialization is made due to a new account
+	 *            installation or just an existing account loading
+	 * 
+	 * @throws OperationFailedException
+	 *             with code INTERNAL_ERROR if we fail initializing the SIP
+	 *             Stack.
+	 * @throws java.lang.IllegalArgumentException
+	 *             if one or more of the account properties have invalid values.
+	 * 
+	 * @see net.java.sip.communicator.service.protocol.AccountID
+	 */
+	protected void initialize(String sipAddress, SipAccountID accountID)
+			throws OperationFailedException, IllegalArgumentException {
+		synchronized (initializationLock) {
+			String logDir = SipActivator.getConfigurationService()
+					.getScHomeDirLocation()
+					+ System.getProperty("file.separator")
+					+ SipActivator.getConfigurationService().getScHomeDirName()
+					+ System.getProperty("file.separator");
 
-            // don't do it more than one time if many provider are initialised
-            if (!NSPVALUE_DEBUG_LOG.startsWith(logDir)) {
-                NSPVALUE_DEBUG_LOG = logDir + NSPVALUE_DEBUG_LOG;
-            }
+			// don't do it more than one time if many provider are initialised
+			if (!NSPVALUE_DEBUG_LOG.startsWith(logDir)) {
+				NSPVALUE_DEBUG_LOG = logDir + NSPVALUE_DEBUG_LOG;
+			}
 
-            if (!NSPVALUE_SERVER_LOG.startsWith(logDir)) {
-                NSPVALUE_SERVER_LOG = logDir + NSPVALUE_SERVER_LOG;
-            }
+			if (!NSPVALUE_SERVER_LOG.startsWith(logDir)) {
+				NSPVALUE_SERVER_LOG = logDir + NSPVALUE_SERVER_LOG;
+			}
 
-            this.accountID = accountID;
+			this.accountID = accountID;
 
-            String protocolIconPath = (String) accountID.getAccountProperties()
-                .get(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
+			String protocolIconPath = (String) accountID.getAccountProperties()
+					.get(ProtocolProviderFactory.PROTOCOL_ICON_PATH);
 
-            if (protocolIconPath == null)
-                protocolIconPath = "resources/images/protocol/sip";
+			if (protocolIconPath == null)
+				protocolIconPath = "resources/images/protocol/sip";
 
-            this.protocolIcon = new ProtocolIconSipImpl(protocolIconPath);
+			this.protocolIcon = new ProtocolIconSipImpl(protocolIconPath);
 
-            this.sipStatusEnum = new SipStatusEnum(protocolIconPath);
+			this.sipStatusEnum = new SipStatusEnum(protocolIconPath);
 
-            sipFactory = SipFactory.getInstance();
-            sipFactory.setPathName("gov.nist");
-            this.jainSipStackProperties = new Properties();
+			sipFactory = SipFactory.getInstance();
+			sipFactory.setPathName("gov.nist");
+			this.jainSipStackProperties = new Properties();
 
-            //init the proxy
-            initOutboundProxy(accountID, jainSipStackProperties);
+			// init the proxy
+			initOutboundProxy(accountID, jainSipStackProperties);
 
-            // If you want to use UDP then uncomment this.
-            jainSipStackProperties.setProperty(
-                JSPNAME_STACK_NAME, "SIP Communicator:"
-                + getAccountID().getAccountUniqueID());
+			// If you want to use UDP then uncomment this.
+			jainSipStackProperties.setProperty(JSPNAME_STACK_NAME,
+					"SIP Communicator:" + getAccountID().getAccountUniqueID());
 
-            // NIST SIP specific properties
-            jainSipStackProperties
-                .setProperty(NSPNAME_DEBUG_LOG, NSPVALUE_DEBUG_LOG);
+			// NIST SIP specific properties
+			jainSipStackProperties.setProperty(NSPNAME_DEBUG_LOG,
+					NSPVALUE_DEBUG_LOG);
 
-            jainSipStackProperties
-                .setProperty(NSPNAME_SERVER_LOG, NSPVALUE_SERVER_LOG);
+			jainSipStackProperties.setProperty(NSPNAME_SERVER_LOG,
+					NSPVALUE_SERVER_LOG);
 
-            // Drop the client connection after we are done with the transaction.
-            jainSipStackProperties
-                .setProperty(   NSPNAME_CACHE_CLIENT_CONNECTIONS,
-                                NSPVALUE_CACHE_CLIENT_CONNECTIONS);
+			// Drop the client connection after we are done with the
+			// transaction.
+			jainSipStackProperties.setProperty(
+					NSPNAME_CACHE_CLIENT_CONNECTIONS,
+					NSPVALUE_CACHE_CLIENT_CONNECTIONS);
 
-            // Log level
-            jainSipStackProperties
-                .setProperty(NSPNAME_TRACE_LEVEL, NSPVALUE_TRACE_LEVEL);
+			// Log level
+			jainSipStackProperties.setProperty(NSPNAME_TRACE_LEVEL,
+					NSPVALUE_TRACE_LEVEL);
 
-            // deliver unsolicited NOTIFY
-            jainSipStackProperties
-                .setProperty(   NSPNAME_DELIVER_UNSOLICITED_NOTIFY,
-                                NSPVALUE_DELIVER_UNSOLICITED_NOTIFY);
+			// deliver unsolicited NOTIFY
+			jainSipStackProperties.setProperty(
+					NSPNAME_DELIVER_UNSOLICITED_NOTIFY,
+					NSPVALUE_DELIVER_UNSOLICITED_NOTIFY);
 
-            try
-            {
-                // Create SipStack object
-                jainSipStack = new SipStackImpl(jainSipStackProperties);
-                logger.debug("Created stack: " + jainSipStack);
-            }
-            catch (PeerUnavailableException exc)
-            {
-                // could not find
-                // gov.nist.jain.protocol.ip.sip.SipStackImpl
-                // in the classpath
-                logger.fatal("Failed to initialize SIP Stack.", exc);
-                throw new OperationFailedException("Failed to create sip stack"
-                    , OperationFailedException.INTERNAL_ERROR
-                    , exc);
-            }
+			try {
+				// Create SipStack object
+				jainSipStack = new SipStackImpl(jainSipStackProperties);
+				logger.debug("Created stack: " + jainSipStack);
+			} catch (PeerUnavailableException exc) {
+				// could not find
+				// gov.nist.jain.protocol.ip.sip.SipStackImpl
+				// in the classpath
+				logger.fatal("Failed to initialize SIP Stack.", exc);
+				throw new OperationFailedException(
+						"Failed to create sip stack",
+						OperationFailedException.INTERNAL_ERROR, exc);
+			}
 
-            //init proxy port
-            int preferredSipPort = ListeningPoint.PORT_5060;
+			// init proxy port
+			int preferredSipPort = ListeningPoint.PORT_5060;
 
-            String proxyPortStr = SipActivator.getConfigurationService().
-                    getString(PREFERRED_SIP_PORT);
+			String proxyPortStr = SipActivator.getConfigurationService()
+					.getString(PREFERRED_SIP_PORT);
 
-            if (proxyPortStr != null && proxyPortStr.length() > 0)
-            {
-                try
-                {
-                    preferredSipPort = Integer.parseInt(proxyPortStr);
-                }
-                catch (NumberFormatException ex)
-                {
-                    logger.error(
-                        proxyPortStr
-                        + " is not a valid port value. Expected an integer"
-                        , ex);
-                }
+			if (proxyPortStr != null && proxyPortStr.length() > 0) {
+				try {
+					preferredSipPort = Integer.parseInt(proxyPortStr);
+				} catch (NumberFormatException ex) {
+					logger
+							.error(
+									proxyPortStr
+											+ " is not a valid port value. Expected an integer",
+									ex);
+				}
 
-                if (preferredSipPort > NetworkUtils.MAX_PORT_NUMBER)
-                {
-                    logger.error(preferredSipPort + " is larger than "
-                                 + NetworkUtils.MAX_PORT_NUMBER + " and does not "
-                                 + "therefore represent a valid port nubmer.");
-                }
-            }
+				if (preferredSipPort > NetworkUtils.MAX_PORT_NUMBER) {
+					logger.error(preferredSipPort + " is larger than "
+							+ NetworkUtils.MAX_PORT_NUMBER + " and does not "
+							+ "therefore represent a valid port nubmer.");
+				}
+			}
 
-            initListeningPoints(preferredSipPort);
+			initListeningPoints(preferredSipPort);
 
-            // get the presence options
-            String enablePresenceObj = (String) accountID
-                    .getAccountProperties().get(
-                            ProtocolProviderFactory.IS_PRESENCE_ENABLED);
+			// get the presence options
+			String enablePresenceObj = (String) accountID
+					.getAccountProperties().get(
+							ProtocolProviderFactory.IS_PRESENCE_ENABLED);
 
-            boolean enablePresence = true;
-            if (enablePresenceObj != null) {
-                enablePresence = Boolean.valueOf(enablePresenceObj)
-                    .booleanValue();
-            }
+			boolean enablePresence = true;
+			if (enablePresenceObj != null) {
+				enablePresence = Boolean.valueOf(enablePresenceObj)
+						.booleanValue();
+			}
 
-            String forceP2PObj = (String) accountID.getAccountProperties()
-                    .get(ProtocolProviderFactory.FORCE_P2P_MODE);
+			String forceP2PObj = (String) accountID.getAccountProperties().get(
+					ProtocolProviderFactory.FORCE_P2P_MODE);
 
-            boolean forceP2P = true;
-            if (forceP2PObj != null) {
-                forceP2P = Boolean.valueOf(forceP2PObj).booleanValue();
-            }
+			boolean forceP2P = true;
+			if (forceP2PObj != null) {
+				forceP2P = Boolean.valueOf(forceP2PObj).booleanValue();
+			}
 
-            int pollingValue = 30;
-            try {
-                String pollingString = (String) accountID.getAccountProperties()
-                        .get(ProtocolProviderFactory.POLLING_PERIOD);
-                if (pollingString != null) {
-                    pollingValue = Integer.parseInt(pollingString);
-                } else {
-                    logger.warn("no polling value found, using default value"
-                            + " (" + pollingValue + ")");
-                }
-            } catch (NumberFormatException e) {
-                logger.error("wrong polling value stored", e);
-            }
+			int pollingValue = 30;
+			try {
+				String pollingString = (String) accountID
+						.getAccountProperties().get(
+								ProtocolProviderFactory.POLLING_PERIOD);
+				if (pollingString != null) {
+					pollingValue = Integer.parseInt(pollingString);
+				} else {
+					logger.warn("no polling value found, using default value"
+							+ " (" + pollingValue + ")");
+				}
+			} catch (NumberFormatException e) {
+				logger.error("wrong polling value stored", e);
+			}
 
-            int subscriptionExpiration = 3600;
-            try {
-                String subscriptionString = (String) accountID
-                    .getAccountProperties().get(ProtocolProviderFactory
-                        .SUBSCRIPTION_EXPIRATION);
-                if (subscriptionString != null) {
-                    subscriptionExpiration = Integer.parseInt(
-                            subscriptionString);
-                } else {
-                    logger.warn("no expiration value found, using default value"
-                            + " (" + subscriptionExpiration + ")");
-                }
-            } catch (NumberFormatException e) {
-                logger.error("wrong expiration value stored", e);
-            }
+			int subscriptionExpiration = 3600;
+			try {
+				String subscriptionString = (String) accountID
+						.getAccountProperties()
+						.get(ProtocolProviderFactory.SUBSCRIPTION_EXPIRATION);
+				if (subscriptionString != null) {
+					subscriptionExpiration = Integer
+							.parseInt(subscriptionString);
+				} else {
+					logger
+							.warn("no expiration value found, using default value"
+									+ " (" + subscriptionExpiration + ")");
+				}
+			} catch (NumberFormatException e) {
+				logger.error("wrong expiration value stored", e);
+			}
 
-            //create SIP factories.
-            headerFactory = new HeaderFactoryImpl();
-            addressFactory = new AddressFactoryImpl();
-            messageFactory = new MessageFactoryImpl();
+			// create SIP factories.
+			headerFactory = new HeaderFactoryImpl();
+			addressFactory = new AddressFactoryImpl();
+			messageFactory = new MessageFactoryImpl();
 
-            //create a connection with the registrar
-            initRegistrarConnection(accountID);
+			// create a connection with the registrar
+			initRegistrarConnection(accountID);
 
-            //init our call processor
-            OperationSetBasicTelephony opSetBasicTelephony
-                = new OperationSetBasicTelephonySipImpl(this);
-            this.supportedOperationSets.put(
-                OperationSetBasicTelephony.class.getName()
-                , opSetBasicTelephony);
+			// init our call processor
+			OperationSetBasicTelephony opSetBasicTelephony = new OperationSetBasicTelephonySipImpl(
+					this);
+			this.supportedOperationSets.put(OperationSetBasicTelephony.class
+					.getName(), opSetBasicTelephony);
 
-            //init presence op set.
-            OperationSetPersistentPresence opSetPersPresence
-                = new OperationSetPresenceSipImpl(this, enablePresence,
-                        forceP2P, pollingValue, subscriptionExpiration);
-            this.supportedOperationSets.put(
-                OperationSetPersistentPresence.class.getName()
-                , opSetPersPresence);
-            //also register with standard presence
-            this.supportedOperationSets.put(
-                OperationSetPresence.class.getName()
-                , opSetPersPresence);
+			// init presence op set.
+			OperationSetPersistentPresence opSetPersPresence = new OperationSetPresenceSipImpl(
+					this, enablePresence, forceP2P, pollingValue,
+					subscriptionExpiration);
+			this.supportedOperationSets.put(
+					OperationSetPersistentPresence.class.getName(),
+					opSetPersPresence);
+			// also register with standard presence
+			this.supportedOperationSets.put(OperationSetPresence.class
+					.getName(), opSetPersPresence);
 
-            // init instant messaging
-            OperationSetBasicInstantMessaging opSetBasicIM =
-                new OperationSetBasicInstantMessagingSipImpl(this);
-            this.supportedOperationSets.put(
-                OperationSetBasicInstantMessaging.class.getName(),
-                opSetBasicIM);
-            
-            // init DTMF (from JM Heitz)
-            OperationSetDTMF opSetDTMF = new OperationSetDTMFSipImpl(this);
-            this.supportedOperationSets.put(
-                OperationSetDTMF.class.getName(), opSetDTMF);
+			// init instant messaging
+			OperationSetBasicInstantMessaging opSetBasicIM = new OperationSetBasicInstantMessagingSipImpl(
+					this);
+			this.supportedOperationSets.put(
+					OperationSetBasicInstantMessaging.class.getName(),
+					opSetBasicIM);
 
+			// init DTMF (from JM Heitz)
+			OperationSetDTMF opSetDTMF = new OperationSetDTMFSipImpl(this);
+			this.supportedOperationSets.put(OperationSetDTMF.class.getName(),
+					opSetDTMF);
 
-            //create our own address.
-            String ourUserID = (String)accountID.getAccountProperties()
-                .get(ProtocolProviderFactory.USER_ID);
+			// init FileTransfer
+			OperationSetFileTransfer opSetFileTransferSipImpl = new OperationSetFileTransferSipImpl(
+					this);
+			this.supportedOperationSets.put(
+					OperationSetFileTransfer.class.getName(),
+					opSetFileTransferSipImpl);
+			
+			// create our own address.
+			String ourUserID = (String) accountID.getAccountProperties().get(
+					ProtocolProviderFactory.USER_ID);
 
-            String sipUriHost = null;
-            if( ourUserID.indexOf("@") != -1
-                && ourUserID.indexOf("@") < ourUserID.length() -1 )
-            {
-                //use the domain in the SIP uri as a default registrar address.
-                sipUriHost = ourUserID.substring( ourUserID.indexOf("@") + 1 );
-                ourUserID = ourUserID.substring( 0, ourUserID.indexOf("@") );
-            }
+			String sipUriHost = null;
+			if (ourUserID.indexOf("@") != -1
+					&& ourUserID.indexOf("@") < ourUserID.length() - 1) {
+				// use the domain in the SIP uri as a default registrar address.
+				sipUriHost = ourUserID.substring(ourUserID.indexOf("@") + 1);
+				ourUserID = ourUserID.substring(0, ourUserID.indexOf("@"));
+			}
 
-            ourDisplayName = (String)accountID.getAccountProperties()
-                .get(ProtocolProviderFactory.DISPLAY_NAME);
+			ourDisplayName = (String) accountID.getAccountProperties().get(
+					ProtocolProviderFactory.DISPLAY_NAME);
 
-            if(sipUriHost == null)
-                sipUriHost = sipRegistrarConnection
-                    .getRegistrarAddress().getHostName();
+			if (sipUriHost == null)
+				sipUriHost = sipRegistrarConnection.getRegistrarAddress()
+						.getHostName();
 
-            SipURI ourSipURI = null;
-            try
-            {
-                ourSipURI = addressFactory.createSipURI(
-                    ourUserID, sipUriHost);
+			SipURI ourSipURI = null;
+			try {
+				ourSipURI = addressFactory.createSipURI(ourUserID, sipUriHost);
 
-                if(ourDisplayName == null
-                   || ourDisplayName.trim().length() == 0)
-                {
-                    ourDisplayName = ourUserID;
-                }
-                ourSipAddress = addressFactory.createAddress(
-                    ourDisplayName, ourSipURI);
-            }
-            catch (ParseException ex)
-            {
-                logger.error("Could not create a SIP URI for user "
-                             + ourUserID + "@" + sipUriHost
-                             + " and registrar " + sipRegistrarConnection
-                             .getRegistrarAddress().getHostName()
-                             , ex);
-                throw new IllegalArgumentException(
-                    "Could not create a SIP URI for user "
-                    + ourUserID + "@" + sipUriHost
-                    + " and registrar " + sipRegistrarConnection
-                                        .getRegistrarAddress().getHostName());
-            }
+				if (ourDisplayName == null
+						|| ourDisplayName.trim().length() == 0) {
+					ourDisplayName = ourUserID;
+				}
+				ourSipAddress = addressFactory.createAddress(ourDisplayName,
+						ourSipURI);
+			} catch (ParseException ex) {
+				logger.error("Could not create a SIP URI for user "
+						+ ourUserID
+						+ "@"
+						+ sipUriHost
+						+ " and registrar "
+						+ sipRegistrarConnection.getRegistrarAddress()
+								.getHostName(), ex);
+				throw new IllegalArgumentException(
+						"Could not create a SIP URI for user "
+								+ ourUserID
+								+ "@"
+								+ sipUriHost
+								+ " and registrar "
+								+ sipRegistrarConnection.getRegistrarAddress()
+										.getHostName());
+			}
 
-            //init the security manager
-            this.sipSecurityManager = new SipSecurityManager(accountID);
-            sipSecurityManager.setHeaderFactory(headerFactory);
-            
-            isInitialized = true;
-        }
-    }
+			// init the security manager
+			this.sipSecurityManager = new SipSecurityManager(accountID);
+			sipSecurityManager.setHeaderFactory(headerFactory);
 
-    /**
-     * Traverses all addresses available at this machine and creates a listening
-     * points on every one of them. The listening points would be initially
-     * bound to the <tt>preferredPortNumber</tt> indicated by the user. If that
-     * fails a new random port will be tried. The whole procedure is repeated
-     * as many times as specified in the BIND_RETRIES property.
-     *
-     * @param preferredPortNumber the port number that we'd like listening
-     * points to be bound to.
-     *
-     * @throws OperationFailedException with code NETWORK_ERROR if we faile
-     * to bind on a local port while and code INTERNAL_ERROR if a jain-sip
-     * operation fails for some reason.
-     */
-    private void initListeningPoints(int preferredPortNumber)
-        throws OperationFailedException
-    {
-        try
-        {
-            String bindRetriesStr
-                = SipActivator.getConfigurationService().getString(
-                    BIND_RETRIES_PROPERTY_NAME);
+			isInitialized = true;
+		}
+	}
 
-            int bindRetries = BIND_RETRIES_DEFAULT_VALUE;
+	/**
+	 * Traverses all addresses available at this machine and creates a listening
+	 * points on every one of them. The listening points would be initially
+	 * bound to the <tt>preferredPortNumber</tt> indicated by the user. If that
+	 * fails a new random port will be tried. The whole procedure is repeated as
+	 * many times as specified in the BIND_RETRIES property.
+	 * 
+	 * @param preferredPortNumber
+	 *            the port number that we'd like listening points to be bound
+	 *            to.
+	 * 
+	 * @throws OperationFailedException
+	 *             with code NETWORK_ERROR if we faile to bind on a local port
+	 *             while and code INTERNAL_ERROR if a jain-sip operation fails
+	 *             for some reason.
+	 */
+	private void initListeningPoints(int preferredPortNumber)
+			throws OperationFailedException {
+		try {
+			String bindRetriesStr = SipActivator.getConfigurationService()
+					.getString(BIND_RETRIES_PROPERTY_NAME);
 
-            if (bindRetriesStr != null)
-            {
-                try
-                {
-                    bindRetries = Integer.parseInt(bindRetriesStr);
-                }
-                catch (NumberFormatException ex)
-                {
-                    logger.error(bindRetriesStr
-                                 + " does not appear to be an integer. "
-                                 + "Defaulting port bind retries to 5.", ex);
-                    bindRetries = BIND_RETRIES_DEFAULT_VALUE;
-                }
-            }
+			int bindRetries = BIND_RETRIES_DEFAULT_VALUE;
 
+			if (bindRetriesStr != null) {
+				try {
+					bindRetries = Integer.parseInt(bindRetriesStr);
+				} catch (NumberFormatException ex) {
+					logger.error(bindRetriesStr
+							+ " does not appear to be an integer. "
+							+ "Defaulting port bind retries to 5.", ex);
+					bindRetries = BIND_RETRIES_DEFAULT_VALUE;
+				}
+			}
 
-            udpListeningPoint = createListeningPoint(preferredPortNumber
-                                                     , ListeningPoint.UDP
-                                                     , bindRetries);
-            tcpListeningPoint = createListeningPoint(preferredPortNumber
-                                                     , ListeningPoint.TCP
-                                                     , bindRetries);
+			udpListeningPoint = createListeningPoint(preferredPortNumber,
+					ListeningPoint.UDP, bindRetries);
+			tcpListeningPoint = createListeningPoint(preferredPortNumber,
+					ListeningPoint.TCP, bindRetries);
 
-            tlsListeningPoint = createListeningPoint(ListeningPoint.PORT_5061
-                                                     , ListeningPoint.TLS
-                                                     , bindRetries);
+			tlsListeningPoint = createListeningPoint(ListeningPoint.PORT_5061,
+					ListeningPoint.TLS, bindRetries);
 
+			try {
+				udpJainSipProvider = jainSipStack
+						.createSipProvider(udpListeningPoint);
+				udpJainSipProvider.addSipListener(this);
+				tcpJainSipProvider = jainSipStack
+						.createSipProvider(tcpListeningPoint);
+				tcpJainSipProvider.addSipListener(this);
+				tlsJainSipProvider = jainSipStack
+						.createSipProvider(tlsListeningPoint);
+				tlsJainSipProvider.addSipListener(this);
 
+				// set our custom address resolver managing SRV records
+				AddressResolverImpl addressResolver = new AddressResolverImpl();
 
-            try
-            {
-                udpJainSipProvider
-                    = jainSipStack.createSipProvider(udpListeningPoint);
-                udpJainSipProvider.addSipListener(this);
-                tcpJainSipProvider
-                    = jainSipStack.createSipProvider(tcpListeningPoint);
-                tcpJainSipProvider.addSipListener(this);
-                tlsJainSipProvider
-                    = jainSipStack.createSipProvider(tlsListeningPoint);
-                tlsJainSipProvider.addSipListener(this);
-                
-                // set our custom address resolver managing SRV records
-                AddressResolverImpl addressResolver = 
-                    new AddressResolverImpl();
-                
-                ((SIPTransactionStack)udpJainSipProvider.getSipStack()).
-                    setAddressResolver(addressResolver);
-                ((SIPTransactionStack)tcpJainSipProvider.getSipStack()).
-                    setAddressResolver(addressResolver);
-                ((SIPTransactionStack)tlsJainSipProvider.getSipStack()).
-                    setAddressResolver(addressResolver);
-            }
-            catch (ObjectInUseException ex)
-            {
-                logger.fatal("Failed to create a SIP Provider", ex);
-                throw new OperationFailedException(
-                    "An error occurred while creating SIP Provider for"
-                    , OperationFailedException.INTERNAL_ERROR
-                    , ex);
-            }
+				((SIPTransactionStack) udpJainSipProvider.getSipStack())
+						.setAddressResolver(addressResolver);
+				((SIPTransactionStack) tcpJainSipProvider.getSipStack())
+						.setAddressResolver(addressResolver);
+				((SIPTransactionStack) tlsJainSipProvider.getSipStack())
+						.setAddressResolver(addressResolver);
+			} catch (ObjectInUseException ex) {
+				logger.fatal("Failed to create a SIP Provider", ex);
+				throw new OperationFailedException(
+						"An error occurred while creating SIP Provider for",
+						OperationFailedException.INTERNAL_ERROR, ex);
+			}
 
-            logger.debug("Created listening points and SIP provider for account"
-                         + "  " + getAccountID().toString());
-        }
-        catch (TransportNotSupportedException ex)
-        {
-            logger.fatal("Failed to create a listening point", ex);
-            throw new OperationFailedException(
-                    "A unexpected error occurred while creating listening point"
-                    , OperationFailedException.INTERNAL_ERROR
-                    , ex);
+			logger
+					.debug("Created listening points and SIP provider for account"
+							+ "  " + getAccountID().toString());
+		} catch (TransportNotSupportedException ex) {
+			logger.fatal("Failed to create a listening point", ex);
+			throw new OperationFailedException(
+					"A unexpected error occurred while creating listening point",
+					OperationFailedException.INTERNAL_ERROR, ex);
 
-        }
-        catch (TooManyListenersException ex)
-        {
-            logger.fatal("Failed to add a provider listener", ex);
-            throw new OperationFailedException(
-                    "A unexpected error occurred while creating listening point"
-                    , OperationFailedException.INTERNAL_ERROR
-                    , ex);
-        }
+		} catch (TooManyListenersException ex) {
+			logger.fatal("Failed to add a provider listener", ex);
+			throw new OperationFailedException(
+					"A unexpected error occurred while creating listening point",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		}
 
-        logger.trace("Done creating listening points.");
-    }
+		logger.trace("Done creating listening points.");
+	}
 
-    /**
-     * Creates a listening point for the specified <tt>transport</tt> first
-     * trying to bind on the <tt>preferredPortNumber</tt>. If the
-     * preferredPortNumber is already used by another program or another
-     * listening point, we will be retrying the operation (<tt>bindRetries</tt>
-     * times in all.)
-     *
-     * @param preferredPortNumber the port number that we should first try to
-     * bind to.
-     * @param transport the transport (UDP/TCP/TLS) of the listening point that
-     * we will be creating
-     * @param bindRetries the number of times that we should try to bind on
-     * different random ports before giving up.
-     * @return the newly creaed <tt>ListeningPoint</tt> instance or
-     * <tt>null</tt> if we didn't manage to create a listening point in bind
-     * retries.
-     *
-     * @throws OperationFailedException with code NETWORK_ERROR if we faile
-     * to bind on a local port while and code INTERNAL_ERROR if a jain-sip
-     * operation fails for some reason.
-     * @throws TransportNotSupportedException if <tt>transport</tt> is not
-     * a valid SIP transport (i.e. not one of UDP/TCP/TLS).
-     */
-    private ListeningPoint createListeningPoint(int preferredPortNumber,
-                                                String transport,
-                                                int bindRetries)
-        throws OperationFailedException, TransportNotSupportedException
-    {
-        int currentlyTriedPort = preferredPortNumber;
+	/**
+	 * Creates a listening point for the specified <tt>transport</tt> first
+	 * trying to bind on the <tt>preferredPortNumber</tt>. If the
+	 * preferredPortNumber is already used by another program or another
+	 * listening point, we will be retrying the operation (<tt>bindRetries</tt>
+	 * times in all.)
+	 * 
+	 * @param preferredPortNumber
+	 *            the port number that we should first try to bind to.
+	 * @param transport
+	 *            the transport (UDP/TCP/TLS) of the listening point that we
+	 *            will be creating
+	 * @param bindRetries
+	 *            the number of times that we should try to bind on different
+	 *            random ports before giving up.
+	 * @return the newly creaed <tt>ListeningPoint</tt> instance or
+	 *         <tt>null</tt> if we didn't manage to create a listening point in
+	 *         bind retries.
+	 * 
+	 * @throws OperationFailedException
+	 *             with code NETWORK_ERROR if we faile to bind on a local port
+	 *             while and code INTERNAL_ERROR if a jain-sip operation fails
+	 *             for some reason.
+	 * @throws TransportNotSupportedException
+	 *             if <tt>transport</tt> is not a valid SIP transport (i.e. not
+	 *             one of UDP/TCP/TLS).
+	 */
+	private ListeningPoint createListeningPoint(int preferredPortNumber,
+			String transport, int bindRetries) throws OperationFailedException,
+			TransportNotSupportedException {
+		int currentlyTriedPort = preferredPortNumber;
 
-        ListeningPoint listeningPoint = null;
+		ListeningPoint listeningPoint = null;
 
-        //we'll first try to bind to the port specified by the user. if
-        //this fails we'll try again times (bindRetries times in all) until
-        //we find a free local port.
-        for (int i = 0; i < bindRetries; i++)
-        {
-            try
-            {
-                //make sure that the we don't already have some other
-                //listening point on this port (possibly initialized from a
-                //different account)
-                if (listeningPointAlreadyBound(currentlyTriedPort
-                                           , transport))
-                {
-                    logger.debug("The following listeing point alredy existed "
-                             + "port: " + currentlyTriedPort + " trans: "
-                             + transport);
-                    throw new InvalidArgumentException("Address already in use");
-                }
+		// we'll first try to bind to the port specified by the user. if
+		// this fails we'll try again times (bindRetries times in all) until
+		// we find a free local port.
+		for (int i = 0; i < bindRetries; i++) {
+			try {
+				// make sure that the we don't already have some other
+				// listening point on this port (possibly initialized from a
+				// different account)
+				if (listeningPointAlreadyBound(currentlyTriedPort, transport)) {
+					logger.debug("The following listeing point alredy existed "
+							+ "port: " + currentlyTriedPort + " trans: "
+							+ transport);
+					throw new InvalidArgumentException("Address already in use");
+				}
 
-                listeningPoint = jainSipStack.createListeningPoint(
-                    NetworkUtils.IN_ADDR_ANY
-                    , currentlyTriedPort
-                    , transport);
-                //we succeeded - break so that we don't try to bind again
-                logger.debug("Created LP " + listeningPoint.getIPAddress()
-                    + ":" + listeningPoint.getPort() + "/"
-                    + listeningPoint.getTransport());
-                try
-                {
-                    listeningPoint.setSentBy("0.0.0.0");
-                }
-                catch (ParseException ex)
-                {
-                }
-                return listeningPoint;
-            }
-            catch (InvalidArgumentException exc)
-            {
-                if (exc.getMessage().indexOf("Address already in use")== -1)
-                {
-                    logger.fatal("An exception occurred while "
-                                 + "trying to create a listening point."
-                                 , exc);
-                    throw new OperationFailedException(
-                        "An error occurred while creating listening points. "
-                        , OperationFailedException.NETWORK_FAILURE
-                        , exc
-                        );
-                }
-            }
-            //port seems to be taken. try another one.
-            logger.debug("Port " + currentlyTriedPort + " seems in use "
-                         +"for transport ." + transport);
-            currentlyTriedPort = NetworkUtils.getRandomPortNumber();
-            logger.debug("Retrying bind on port " + currentlyTriedPort);
+				listeningPoint = jainSipStack
+						.createListeningPoint(NetworkUtils.IN_ADDR_ANY,
+								currentlyTriedPort, transport);
+				// we succeeded - break so that we don't try to bind again
+				logger.debug("Created LP " + listeningPoint.getIPAddress()
+						+ ":" + listeningPoint.getPort() + "/"
+						+ listeningPoint.getTransport());
+				try {
+					listeningPoint.setSentBy("0.0.0.0");
+				} catch (ParseException ex) {
+				}
+				return listeningPoint;
+			} catch (InvalidArgumentException exc) {
+				if (exc.getMessage().indexOf("Address already in use") == -1) {
+					logger.fatal("An exception occurred while "
+							+ "trying to create a listening point.", exc);
+					throw new OperationFailedException(
+							"An error occurred while creating listening points. ",
+							OperationFailedException.NETWORK_FAILURE, exc);
+				}
+			}
+			// port seems to be taken. try another one.
+			logger.debug("Port " + currentlyTriedPort + " seems in use "
+					+ "for transport ." + transport);
+			currentlyTriedPort = NetworkUtils.getRandomPortNumber();
+			logger.debug("Retrying bind on port " + currentlyTriedPort);
 
-        }
+		}
 
-        logger.error("Failed to create a listening point for tranport "
-                     + transport);
-        return null;
-    }
+		logger.error("Failed to create a listening point for tranport "
+				+ transport);
+		return null;
+	}
 
-    /**
-     * Verifies whether a listening point for the specified port and transport
-     * already exists. We need this method because we can only have one single
-     * stack per JVM and it is possible for some other account to have already
-     * created a listening point for a port that we're trying to bind on. Yet
-     * that would be undesirable as we would not like to receive any of the SIP
-     * messages meannt for the other account.
-     *
-     * @param port the port number that we're interested in.
-     * @param transport the transport of the listening point we're looking for.
-     *
-     * @return true if a ListeningPoint already exists for the specified port
-     * and tranport and false otherwise.
-     */
-    private boolean listeningPointAlreadyBound(int     port,
-                                               String  transport)
-    {
-        if(jainSipStack == null)
-        {
-            return false;
-        }
+	/**
+	 * Verifies whether a listening point for the specified port and transport
+	 * already exists. We need this method because we can only have one single
+	 * stack per JVM and it is possible for some other account to have already
+	 * created a listening point for a port that we're trying to bind on. Yet
+	 * that would be undesirable as we would not like to receive any of the SIP
+	 * messages meannt for the other account.
+	 * 
+	 * @param port
+	 *            the port number that we're interested in.
+	 * @param transport
+	 *            the transport of the listening point we're looking for.
+	 * 
+	 * @return true if a ListeningPoint already exists for the specified port
+	 *         and tranport and false otherwise.
+	 */
+	private boolean listeningPointAlreadyBound(int port, String transport) {
+		if (jainSipStack == null) {
+			return false;
+		}
 
-        //What really matters is not the transport of the listening point but
-        //whether it is UDP or TCP (i.e. TLS listening points have to be
-        //considered as TCP).
-        boolean searchTransportIsUDP = transport.equals(ListeningPoint.UDP);
+		// What really matters is not the transport of the listening point but
+		// whether it is UDP or TCP (i.e. TLS listening points have to be
+		// considered as TCP).
+		boolean searchTransportIsUDP = transport.equals(ListeningPoint.UDP);
 
-        Iterator existingListeningPoints = jainSipStack.getListeningPoints();
+		Iterator existingListeningPoints = jainSipStack.getListeningPoints();
 
-        while(existingListeningPoints.hasNext())
-        {
-            ListeningPoint lp = (ListeningPoint)existingListeningPoints.next();
+		while (existingListeningPoints.hasNext()) {
+			ListeningPoint lp = (ListeningPoint) existingListeningPoints.next();
 
-            if(lp.getPort() == port)
-            {
-                boolean lpIsUDP = lp.getTransport().equalsIgnoreCase(
-                                                        ListeningPoint.UDP);
+			if (lp.getPort() == port) {
+				boolean lpIsUDP = lp.getTransport().equalsIgnoreCase(
+						ListeningPoint.UDP);
 
-                if(lpIsUDP == searchTransportIsUDP)
-                {
-                    return true;
-                }
-            }
-        }
+				if (lpIsUDP == searchTransportIsUDP) {
+					return true;
+				}
+			}
+		}
 
-        return false;
-    }
+		return false;
+	}
 
-    /**
-     * Process an asynchronously reported IO Exception. Asynchronous IO
-     * Exceptions may occur as a result of errors during retransmission of
-     * requests. The transaction state machine requires to report IO Exceptions
-     * to the application immediately (according to RFC 3261). This method
-     * enables an implementation to propagate the asynchronous handling of IO
-     * Exceptions to the application.
-     *
-     * @param exceptionEvent The Exception event that is reported to the
-     * application.
-     */
-    public void processIOException(IOExceptionEvent exceptionEvent)
-    {
-        /**@todo implement processIOException() */
-        logger.debug("@todo implement processIOException()");
-    }
+	/**
+	 * Process an asynchronously reported IO Exception. Asynchronous IO
+	 * Exceptions may occur as a result of errors during retransmission of
+	 * requests. The transaction state machine requires to report IO Exceptions
+	 * to the application immediately (according to RFC 3261). This method
+	 * enables an implementation to propagate the asynchronous handling of IO
+	 * Exceptions to the application.
+	 * 
+	 * @param exceptionEvent
+	 *            The Exception event that is reported to the application.
+	 */
+	public void processIOException(IOExceptionEvent exceptionEvent) {
+		/** @todo implement processIOException() */
+		logger.debug("@todo implement processIOException()");
+	}
 
-    /**
-     * Processes a Response received on a SipProvider upon which this
-     * SipListener is registered.
-     * <p>
-     *
-     * @param responseEvent the responseEvent fired from the SipProvider to the
-     * SipListener representing a Response received from the network.
-     */
-    public void processResponse(ResponseEvent responseEvent)
-    {
-        logger.debug("received response=\n" + responseEvent.getResponse());
-        ClientTransaction clientTransaction = responseEvent
-            .getClientTransaction();
-        if (clientTransaction == null) {
-            logger.debug("ignoring a transactionless response");
-            return;
-        }
+	/**
+	 * Processes a Response received on a SipProvider upon which this
+	 * SipListener is registered.
+	 * <p>
+	 * 
+	 * @param responseEvent
+	 *            the responseEvent fired from the SipProvider to the
+	 *            SipListener representing a Response received from the network.
+	 */
+	public void processResponse(ResponseEvent responseEvent) {
+		logger.debug("received response=\n" + responseEvent.getResponse());
+		ClientTransaction clientTransaction = responseEvent
+				.getClientTransaction();
+		if (clientTransaction == null) {
+			logger.debug("ignoring a transactionless response");
+			return;
+		}
 
-        Response response = responseEvent.getResponse();
-        String method = ( (CSeqHeader) response.getHeader(CSeqHeader.NAME))
-            .getMethod();
+		Response response = responseEvent.getResponse();
+		String method = ((CSeqHeader) response.getHeader(CSeqHeader.NAME))
+				.getMethod();
 
-        //find the object that is supposed to take care of responses with the
-        //corresponding method
-        SipListener processor = (SipListener)methodProcessors.get(method);
+		// find the object that is supposed to take care of responses with the
+		// corresponding method
+		List<SipListener> processors = (List<SipListener>) methodProcessors
+				.get(method);
 
-        if(processor == null)
-        {
-            return;
-        }
-        
-        logger.debug("Found one processor for method " + method
-                     + ", processor is=" + processor.toString());
-            
-            processor.processResponse(responseEvent);
-    }
+		if (processors == null) {
+			return;
+		}
 
-    /**
-     * Processes a retransmit or expiration Timeout of an underlying
-     * {@link Transaction} handled by this SipListener. This Event notifies the
-     * application that a retransmission or transaction Timer expired in the
-     * SipProvider's transaction state machine. The TimeoutEvent encapsulates
-     * the specific timeout type and the transaction identifier either client or
-     * server upon which the timeout occured. The type of Timeout can by
-     * determined by:
-     * <code>timeoutType = timeoutEvent.getTimeout().getValue();</code>
-     *
-     * @param timeoutEvent -
-     *            the timeoutEvent received indicating either the message
-     *            retransmit or transaction timed out.
-     */
-    public void processTimeout(TimeoutEvent timeoutEvent)
-    {
-        Transaction transaction;
-        if(timeoutEvent.isServerTransaction())
-            transaction = timeoutEvent.getServerTransaction();
-        else
-            transaction = timeoutEvent.getClientTransaction();
+		for (SipListener processor : processors) {
 
-        if (transaction == null) {
-            logger.debug("ignoring a transactionless timeout event");
-            return;
-        }
+			logger.debug("Found one *PROCESSOR* for method " + method
+					+ ", processor is=" + processor.toString()
+					+ processor.getClass().getCanonicalName());
 
-        Request request = transaction.getRequest();
-        logger.debug("received timeout for req=" + request);
+			processor.processResponse(responseEvent);
+		}
+	}
 
+	/**
+	 * Processes a retransmit or expiration Timeout of an underlying
+	 * {@link Transaction} handled by this SipListener. This Event notifies the
+	 * application that a retransmission or transaction Timer expired in the
+	 * SipProvider's transaction state machine. The TimeoutEvent encapsulates
+	 * the specific timeout type and the transaction identifier either client or
+	 * server upon which the timeout occured. The type of Timeout can by
+	 * determined by:
+	 * <code>timeoutType = timeoutEvent.getTimeout().getValue();</code>
+	 * 
+	 * @param timeoutEvent
+	 *            - the timeoutEvent received indicating either the message
+	 *            retransmit or transaction timed out.
+	 */
+	public void processTimeout(TimeoutEvent timeoutEvent) {
+		Transaction transaction;
+		if (timeoutEvent.isServerTransaction())
+			transaction = timeoutEvent.getServerTransaction();
+		else
+			transaction = timeoutEvent.getClientTransaction();
 
-        //find the object that is supposed to take care of responses with the
-        //corresponding method
-        SipListener processor
-            = (SipListener)methodProcessors.get(request.getMethod());
+		if (transaction == null) {
+			logger.debug("ignoring a transactionless timeout event");
+			return;
+		}
 
-        if (processor == null)
-        {
-            return;
-        }
-        
-        logger.debug("Found one processor for method " + request.getMethod()
-                     + ", processor is=" + processor.toString());
-            
-            processor.processTimeout(timeoutEvent);
-    }
+		Request request = transaction.getRequest();
+		logger.debug("received timeout for req=\n" + request);
 
-    /**
-     * Process an asynchronously reported TransactionTerminatedEvent.
-     * When a transaction transitions to the Terminated state, the stack
-     * keeps no further records of the transaction. This notification can be used by
-     * applications to clean up any auxiliary data that is being maintained
-     * for the given transaction.
-     *
-     * @param transactionTerminatedEvent -- an event that indicates that the
-     *       transaction has transitioned into the terminated state.
-     * @since v1.2
-     */
-    public void processTransactionTerminated(TransactionTerminatedEvent
-                                             transactionTerminatedEvent)
-    {
-        Transaction transaction;
-        if(transactionTerminatedEvent.isServerTransaction())
-            transaction = transactionTerminatedEvent.getServerTransaction();
-        else
-            transaction = transactionTerminatedEvent.getClientTransaction();
+		// find the object that is supposed to take care of responses with the
+		// corresponding method
+		List<SipListener> processors = (List<SipListener>) methodProcessors
+				.get(request.getMethod());
 
-        if (transaction == null) {
-            logger.debug(
-                "ignoring a transactionless transaction terminated event");
-            return;
-        }
+		if (processors == null) {
+			return;
+		}
 
-        Request request = transaction.getRequest();
-        logger.debug("Transaction terminated for req=" + request);
+		for (SipListener processor : processors) {
 
+			logger.debug("Found one *PROCESSOR* for method "
+					+ request.getMethod() + ", processor is="
+					+ processor.toString()
+					+ processor.getClass().getCanonicalName());
 
-        //find the object that is supposed to take care of responses with the
-        //corresponding method
-        SipListener processor
-            = (SipListener)methodProcessors.get(request.getMethod());
+			processor.processTimeout(timeoutEvent);
+		}
+	}
 
-        if(processor == null)
-        {
-            return;
-        }
-        
-        logger.debug("Found one processor for method " + request.getMethod()
-                     + ", processor is=" + processor.toString());
-            
-            processor.processTransactionTerminated(transactionTerminatedEvent);
-    }
+	/**
+	 * Process an asynchronously reported TransactionTerminatedEvent. When a
+	 * transaction transitions to the Terminated state, the stack keeps no
+	 * further records of the transaction. This notification can be used by
+	 * applications to clean up any auxiliary data that is being maintained for
+	 * the given transaction.
+	 * 
+	 * @param transactionTerminatedEvent
+	 *            -- an event that indicates that the transaction has
+	 *            transitioned into the terminated state.
+	 * @since v1.2
+	 */
+	public void processTransactionTerminated(
+			TransactionTerminatedEvent transactionTerminatedEvent) {
+		Transaction transaction;
+		if (transactionTerminatedEvent.isServerTransaction())
+			transaction = transactionTerminatedEvent.getServerTransaction();
+		else
+			transaction = transactionTerminatedEvent.getClientTransaction();
 
-    /**
-     * Process an asynchronously reported DialogTerminatedEvent.
-     * When a dialog transitions to the Terminated state, the stack
-     * keeps no further records of the dialog. This notification can be used by
-     * applications to clean up any auxiliary data that is being maintained
-     * for the given dialog.
-     *
-     * @param dialogTerminatedEvent -- an event that indicates that the
-     *       dialog has transitioned into the terminated state.
-     * @since v1.2
-     */
-    public void processDialogTerminated(DialogTerminatedEvent
-                                        dialogTerminatedEvent)
-    {
-        logger.debug("Dialog terminated for req="
-                     + dialogTerminatedEvent.getDialog());
-    }
+		if (transaction == null) {
+			logger
+					.debug("ignoring a transactionless transaction terminated event");
+			return;
+		}
 
-    /**
-     * Processes a Request received on a SipProvider upon which this SipListener
-     * is registered.
-     * <p>
-     * @param requestEvent requestEvent fired from the SipProvider to the
-     * SipListener representing a Request received from the network.
-     */
-    public void processRequest(RequestEvent requestEvent)
-    {
-        logger.debug("received request=\n" + requestEvent.getRequest());
+		Request request = transaction.getRequest();
+		logger.debug("Transaction terminated for req=\r" + request);
 
-        Request request = requestEvent.getRequest();
-        
-        // test if an Event header is present and known
-        EventHeader eventHeader = (EventHeader) 
-            request.getHeader(EventHeader.NAME);
-        
-        if (eventHeader != null) {
-            boolean eventKnown;
-            
-            synchronized (this.registeredEvents) {
-                eventKnown = this.registeredEvents.contains(
-                        eventHeader.getEventType());
-            }
-            
-            if (!eventKnown) {
-                // send a 489 / Bad Event response
-                ServerTransaction serverTransaction = requestEvent
-                    .getServerTransaction();
-                SipProvider jainSipProvider = (SipProvider)
-                    requestEvent.getSource();
-                
-                if (serverTransaction == null)
-                {
-                    try
-                    {
-                        serverTransaction = jainSipProvider
-                            .getNewServerTransaction(request);
-                    }
-                    catch (TransactionAlreadyExistsException ex)
-                    {
-                        //let's not scare the user and only log a message
-                        logger.error("Failed to create a new server"
-                            + "transaction for an incoming request\n"
-                            + "(Next message contains the request)"
-                            , ex);
-                        return;
-                    }
-                    catch (TransactionUnavailableException ex)
-                    {
-                        //let's not scare the user and only log a message
-                        logger.error("Failed to create a new server"
-                            + "transaction for an incoming request\n"
-                            + "(Next message contains the request)"
-                            , ex);
-                            return;
-                    }
-                }
-                
-                Response response = null;
-                try {
-                    response = this.getMessageFactory().createResponse(
-                            Response.BAD_EVENT, request);
-                } catch (ParseException e) {
-                    logger.error("failed to create the 489 response", e);
-                    return;
-                }
+		// find the object that is supposed to take care of responses with the
+		// corresponding method
+		List<SipListener> processors = (List<SipListener>) methodProcessors
+				.get(request.getMethod());
 
-                try {
-                    serverTransaction.sendResponse(response);
-                } catch (SipException e) {
-                    logger.error("failed to send the response", e);
-                } catch (InvalidArgumentException e) {
-                    // should not happen
-                    logger.error("invalid argument provided while trying" +
-                            " to send the response", e);
-                }
-            }
-        }
-        
+		if (processors == null) {
+			return;
+		}
 
-        String method = request.getMethod();
+		for (SipListener processor : processors) {
 
-        //find the object that is supposed to take care of responses with the
-        //corresponding method
-        SipListener processor = (SipListener)methodProcessors.get(method);
+			logger.debug("Found one *PROCESSOR* for method "
+					+ request.getMethod() + ", processor is="
+					+ processor.toString() + "class: "
+					+ processor.getClass().getCanonicalName());
 
-        if(processor == null)
-        {
-            return;
-        }
-        
-        logger.debug("Found one processor for method " + method
-                     + ", processor is=" + processor.toString());
-            
-            processor.processRequest(requestEvent);
-    }
+			processor.processTransactionTerminated(transactionTerminatedEvent);
+		}
+	}
 
-    /**
-     * Makes the service implementation close all open sockets and release
-     * any resources that it might have taken and prepare for shutdown/garbage
-     * collection.
-     */
-    public void shutdown()
-    {
-        if(!isInitialized)
-        {
-            return;
-        }
-        
-        // launch the shutdown process in a thread to free the GUI as soon
-        // as possible even if the SIP unregistration process may take time
-        // especially for ending SIMPLE
-        Thread t = new Thread(new ShutdownThread());
-        t.setDaemon(false);
-        t.run();
+	/**
+	 * Process an asynchronously reported DialogTerminatedEvent. When a dialog
+	 * transitions to the Terminated state, the stack keeps no further records
+	 * of the dialog. This notification can be used by applications to clean up
+	 * any auxiliary data that is being maintained for the given dialog.
+	 * 
+	 * @param dialogTerminatedEvent
+	 *            -- an event that indicates that the dialog has transitioned
+	 *            into the terminated state.
+	 * @since v1.2
+	 */
+	public void processDialogTerminated(
+			DialogTerminatedEvent dialogTerminatedEvent) {
+		logger.debug("Dialog terminated for req=\n"
+				+ dialogTerminatedEvent.getDialog());
+	}
 
-    }
-    
-    protected class ShutdownThread implements Runnable
-    {
-        public void run() {
-            logger.trace("Killing the SIP Protocol Provider.");
-            //kill all active calls
-            OperationSetBasicTelephonySipImpl telephony
-                = (OperationSetBasicTelephonySipImpl)getOperationSet(
-                    OperationSetBasicTelephony.class);
-            telephony.shutdown();
+	/**
+	 * Processes a Request received on a SipProvider upon which this SipListener
+	 * is registered.
+	 * <p>
+	 * 
+	 * @param requestEvent
+	 *            requestEvent fired from the SipProvider to the SipListener
+	 *            representing a Request received from the network.
+	 */
+	public void processRequest(RequestEvent requestEvent) {
+		logger.debug("received request=\n" + requestEvent.getRequest());
 
-            if(isRegistered())
-            {
-                try
-                {
-                    //create a listener that would notify us when unregistration
-                    //has completed.
-                    ShutdownUnregistrationBlockListener listener
-                        = new ShutdownUnregistrationBlockListener();
-                    addRegistrationStateChangeListener(listener);
+		Request request = requestEvent.getRequest();
 
-                    //do the unregistration
-                    unregister();
+		// test if an Event header is present and known
+		EventHeader eventHeader = (EventHeader) request
+				.getHeader(EventHeader.NAME);
 
-                    //leave ourselves time to complete unregistration (may include
-                    //2 REGISTER requests in case notification is needed.)
-                    listener.waitForEvent(5000);
-                }
-                catch (OperationFailedException ex)
-                {
-                    //we're shutting down so we need to silence the exception here
-                    logger.error(
-                        "Failed to properly unregister before shutting down. "
-                        + getAccountID()
-                        , ex);
-                }
-            }
+		if (eventHeader != null) {
+			boolean eventKnown;
 
-            try
-            {
-                udpJainSipProvider.removeListeningPoint(udpListeningPoint);
-                tcpJainSipProvider.removeListeningPoint(tcpListeningPoint);
-                tlsJainSipProvider.removeListeningPoint(tlsListeningPoint);
-            }
-            catch (ObjectInUseException ex)
-            {
-                logger.info("An exception occurred while ", ex);
-            }
+			synchronized (this.registeredEvents) {
+				eventKnown = this.registeredEvents.contains(eventHeader
+						.getEventType());
+			}
 
-            try
-            {
-//                this.jainSipStack.stop();
-            }
-            catch (Exception ex)
-            {
-                //catch anything the stack can throw at us here so that we could
-                //peacefully finish our shutdown.
-                logger.error("Failed to properly stop the stack!", ex);
-            }
+			if (!eventKnown) {
+				// send a 489 / Bad Event response
+				ServerTransaction serverTransaction = requestEvent
+						.getServerTransaction();
+				SipProvider jainSipProvider = (SipProvider) requestEvent
+						.getSource();
 
-            udpListeningPoint = null;
-            tcpListeningPoint = null;
-            tlsListeningPoint = null;
-            udpJainSipProvider = null;
-            tcpJainSipProvider = null;
-            tlsJainSipProvider = null;
-            headerFactory = null;
-            messageFactory = null;
-            addressFactory = null;
-            sipFactory = null;
-            sipSecurityManager = null;
+				if (serverTransaction == null) {
+					try {
+						serverTransaction = jainSipProvider
+								.getNewServerTransaction(request);
+					} catch (TransactionAlreadyExistsException ex) {
+						// let's not scare the user and only log a message
+						logger.error("Failed to create a new server"
+								+ "transaction for an incoming request\n"
+								+ "(Next message contains the request)", ex);
+						return;
+					} catch (TransactionUnavailableException ex) {
+						// let's not scare the user and only log a message
+						logger.error("Failed to create a new server"
+								+ "transaction for an incoming request\n"
+								+ "(Next message contains the request)", ex);
+						return;
+					}
+				}
 
-            methodProcessors.clear();
+				Response response = null;
+				try {
+					response = this.getMessageFactory().createResponse(
+							Response.BAD_EVENT, request);
+				} catch (ParseException e) {
+					logger.error("failed to create the 489 response", e);
+					return;
+				}
 
-            isInitialized = false;
-        }
-    }
+				try {
+					serverTransaction.sendResponse(response);
+				} catch (SipException e) {
+					logger.error("failed to send the response", e);
+				} catch (InvalidArgumentException e) {
+					// should not happen
+					logger.error("invalid argument provided while trying"
+							+ " to send the response", e);
+				}
+			}
+		}
 
-    /**
-     * Generate a tag for a FROM header or TO header. Just return a random 4
-     * digit integer (should be enough to avoid any clashes!) Tags only need to
-     * be unique within a call.
-     *
-     * @return a string that can be used as a tag parameter.
-     *
-     * synchronized: needed for access to 'rand', else risk to generate same tag
-     * twice
-     */
-    public static synchronized String generateLocalTag()
-    {
-            return Integer.toHexString(localTagGenerator.nextInt());
-    }
+		String method = request.getMethod();
 
-    /**
-     * Initializes and returns an ArrayList with a single ViaHeader
-     * containing a localhost address usable with the specified
-     * s<tt>destination</tt>. This ArrayList may be used when sending
-     * requests to that destination.
-     * <p>
-     * @param destination The address of the destination that the request using
-     * the via headers will be sent to.
-     * @param srcListeningPoint the listening point that we will be using when
-     * accessing destination.
-     *
-     * @return ViaHeader-s list to be used when sending requests.
-     * @throws OperationFailedException code INTERNAL_ERROR if a ParseException
-     * occurs while initializing the array list.
-     *
-     */
-    public ArrayList getLocalViaHeaders(InetAddress destination,
-                                        ListeningPoint srcListeningPoint)
-        throws OperationFailedException
-    {
-        ArrayList viaHeaders = new ArrayList();
-        try
-        {
-            InetAddress localAddress = SipActivator
-                .getNetworkAddressManagerService().getLocalHost(destination);
-            ViaHeader viaHeader = headerFactory.createViaHeader(
-                localAddress.getHostAddress()
-                , srcListeningPoint.getPort()
-                , srcListeningPoint.getTransport()
-                , null
-                );
-            viaHeaders.add(viaHeader);
-            logger.debug("generated via headers:" + viaHeader);
-            return viaHeaders;
-        }
-        catch (ParseException ex)
-        {
-            logger.error(
-                "A ParseException occurred while creating Via Headers!", ex);
-            throw new OperationFailedException(
-                "A ParseException occurred while creating Via Headers!"
-                ,OperationFailedException.INTERNAL_ERROR
-                ,ex);
-        }
-        catch (InvalidArgumentException ex)
-        {
-            logger.error(
-                "Unable to create a via header for port "
-                + udpListeningPoint.getPort(),
-                ex);
-            throw new OperationFailedException(
-                "Unable to create a via header for port "
-                + udpListeningPoint.getPort()
-                ,OperationFailedException.INTERNAL_ERROR
-                ,ex);
-        }
-    }
+		// find the object that is supposed to take care of responses with the
+		// corresponding method
+		List<SipListener> processors = (List<SipListener>) methodProcessors
+				.get(request.getMethod());
 
-    /**
-     * Initializes and returns this provider's default maxForwardsHeader field
-     * using the value specified by MAX_FORWARDS.
-     *
-     * @return an instance of a MaxForwardsHeader that can be used when
-     * sending requests
-     *
-     * @throws OperationFailedException with code INTERNAL_ERROR if MAX_FORWARDS
-     * has an invalid value.
-     */
-    public MaxForwardsHeader getMaxForwardsHeader() throws
-        OperationFailedException
-    {
-        if (maxForwardsHeader == null)
-        {
-            try
-            {
-                maxForwardsHeader = headerFactory.createMaxForwardsHeader(
-                    MAX_FORWARDS);
-                logger.debug("generated max forwards: "
-                             + maxForwardsHeader.toString());
-            }
-            catch (InvalidArgumentException ex)
-            {
-                throw new OperationFailedException(
-                    "A problem occurred while creating MaxForwardsHeader"
-                    , OperationFailedException.INTERNAL_ERROR
-                    , ex);
-            }
-        }
+		if (processors == null) {
+			return;
+		}
 
-        return maxForwardsHeader;
-    }
+		for (SipListener processor : processors) {
 
-    /**
-     * Retrns a Contact header containing our sip uri and therefore usable in all
-     * but REGISTER requests. Same as calling getContactHeader(false)
-     *
-     * @return a Contact header containing our sip uri
-     */
-    public ContactHeader getContactHeader()
-    {
-        if(this.genericContactHeader == null)
-        {
-            try
-            {
-                genericContactHeader = getContactHeader(
-                    sipRegistrarConnection.getRegistrarAddress(),
-                    sipRegistrarConnection.getRegistrarListeningPoint());
-            }
-            catch(OperationFailedException ex)
-            {
-                logger.error("Failed to create Contact header.", ex);
-            }
-            logger.debug("generated contactHeader:"
-                         + genericContactHeader);
-        }
-        return genericContactHeader;
-    }
+			logger.debug("Found one *PROCESSOR* for method "
+					+ request.getMethod() + ", processor is="
+					+ processor.toString()
+					+ processor.getClass().getCanonicalName());
 
-    /**
-     * Retrns a Contact header containing a sip URI base on a localhost address
-     * and thereforeusable in REGISTER requests only.
-     *
-     * @param targetAddress the address of the registrar that this contact
-     * header is meant for.
-     * @param srcListeningPoint the listening point that will be used when
-     * accessing the registrar.
-     *
-     * @return a Contact header based upon a local inet address.
-     * @throws OperationFailedException if we fail constructing the contact
-     * header.
-     */
-    ContactHeader getContactHeader(InetAddress targetAddress,
-                                   ListeningPoint srcListeningPoint)
-        throws OperationFailedException
-    {
-        ContactHeader registrationContactHeader = null;
-        try
-        {
-            //find the address to use with the target
-            InetAddress localAddress = SipActivator
-                .getNetworkAddressManagerService().getLocalHost(targetAddress);
+			processor.processRequest(requestEvent);
+		}
+	}
 
-            SipURI contactURI = addressFactory.createSipURI(
-                ((SipURI)ourSipAddress.getURI()).getUser()
-                , localAddress.getHostAddress() );
+	/**
+	 * Makes the service implementation close all open sockets and release any
+	 * resources that it might have taken and prepare for shutdown/garbage
+	 * collection.
+	 */
+	public void shutdown() {
+		if (!isInitialized) {
+			return;
+		}
 
-            contactURI.setTransportParam(srcListeningPoint.getTransport());
-            contactURI.setPort(srcListeningPoint.getPort());
-            Address contactAddress = addressFactory.createAddress( contactURI );
+		// launch the shutdown process in a thread to free the GUI as soon
+		// as possible even if the SIP unregistration process may take time
+		// especially for ending SIMPLE
+		Thread t = new Thread(new ShutdownThread());
+		t.setDaemon(false);
+		t.run();
 
-            if (ourDisplayName != null)
-            {
-                contactAddress.setDisplayName(ourDisplayName);
-            }
-            registrationContactHeader = headerFactory.createContactHeader(
-                contactAddress);
-            logger.debug("generated contactHeader:"
-                         + registrationContactHeader);
-        }
-        catch (ParseException ex)
-        {
-            logger.error(
-                "A ParseException occurred while creating From Header!", ex);
-            throw new OperationFailedException(
-                "A ParseException occurred while creating From Header!"
-                , OperationFailedException.INTERNAL_ERROR
-                , ex);
-        }
-        return registrationContactHeader;
-    }
+	}
 
-    /**
-     * Returns the AddressFactory used to create URLs ans Address objects.
-     *
-     * @return the AddressFactory used to create URLs ans Address objects.
-     */
-    public AddressFactory getAddressFactory()
-    {
-        return addressFactory;
-    }
+	protected class ShutdownThread implements Runnable {
+		public void run() {
+			logger.trace("Killing the SIP Protocol Provider.");
+			// kill all active calls
+			OperationSetBasicTelephonySipImpl telephony = (OperationSetBasicTelephonySipImpl) getOperationSet(OperationSetBasicTelephony.class);
+			telephony.shutdown();
 
-    /**
-     * Returns the HeaderFactory used to create SIP message headers.
-     *
-     * @return the HeaderFactory used to create SIP message headers.
-     */
-    public HeaderFactory getHeaderFactory()
-    {
-        return headerFactory;
-    }
+			if (isRegistered()) {
+				try {
+					// create a listener that would notify us when
+					// unregistration
+					// has completed.
+					ShutdownUnregistrationBlockListener listener = new ShutdownUnregistrationBlockListener();
+					addRegistrationStateChangeListener(listener);
 
-    /**
-     * Returns the Message Factory used to create SIP messages.
-     *
-     * @return the Message Factory used to create SIP messages.
-     */
-    public MessageFactory getMessageFactory()
-    {
-        return messageFactory;
-    }
+					// do the unregistration
+					unregister();
 
-    /**
-     * Returns the sipStack instance that handles SIP communications.
-     *
-     * @return  the sipStack instance that handles SIP communications.
-     */
-    public SipStack getJainSipStack()
-    {
-        return jainSipStack;
-    }
+					// leave ourselves time to complete unregistration (may
+					// include
+					// 2 REGISTER requests in case notification is needed.)
+					listener.waitForEvent(5000);
+				} catch (OperationFailedException ex) {
+					// we're shutting down so we need to silence the exception
+					// here
+					logger.error(
+							"Failed to properly unregister before shutting down. "
+									+ getAccountID(), ex);
+				}
+			}
 
-    /**
-     * Returns the default listening point that we use for communication over
-     * <tt>transport</tt>.
-     *
-     * @param transport the transport that the returned listening point needs
-     * to support.
-     *
-     * @return the default listening point that we use for communication over
-     * <tt>transport</tt> or null if no such transport is supported.
-     */
-    public ListeningPoint getListeningPoint(String transport)
-    {
-        if(transport.equalsIgnoreCase(ListeningPoint.UDP))
-        {
-            return udpListeningPoint;
-        }
-        else if(transport.equalsIgnoreCase(ListeningPoint.TCP))
-        {
-            return tcpListeningPoint;
-        }
-        else if(transport.equalsIgnoreCase(ListeningPoint.TLS))
-        {
-            return tlsListeningPoint;
-        }
-        return null;
-    }
+			try {
+				udpJainSipProvider.removeListeningPoint(udpListeningPoint);
+				tcpJainSipProvider.removeListeningPoint(tcpListeningPoint);
+				tlsJainSipProvider.removeListeningPoint(tlsListeningPoint);
+			} catch (ObjectInUseException ex) {
+				logger.info("An exception occurred while ", ex);
+			}
 
-    /**
-     * Returns the default jain sip provider that we use for communication over
-     * <tt>transport</tt>.
-     *
-     * @param transport the transport that the returned provider needs
-     * to support.
-     *
-     * @return the default jain sip provider that we use for communication over
-     * <tt>transport</tt> or null if no such transport is supported.
-     */
-    public SipProvider getJainSipProvider(String transport)
-    {
-        if(transport.equalsIgnoreCase(ListeningPoint.UDP))
-        {
-            return udpJainSipProvider;
-        }
-        else if(transport.equalsIgnoreCase(ListeningPoint.TCP))
-        {
-            return tcpJainSipProvider;
-        }
-        else if(transport.equalsIgnoreCase(ListeningPoint.TLS))
-        {
-            return tlsJainSipProvider;
-        }
-        return null;
-    }
+			try {
+				// this.jainSipStack.stop();
+			} catch (Exception ex) {
+				// catch anything the stack can throw at us here so that we
+				// could
+				// peacefully finish our shutdown.
+				logger.error("Failed to properly stop the stack!", ex);
+			}
 
-    /**
-     * Reurns the currently valid sip security manager that everyone should
-     * use to authenticate SIP Requests.
-     * @return the currently valid instace of a SipSecurityManager that everyone
-     * sould use to authenticate SIP Requests.
-     */
-    public SipSecurityManager getSipSecurityManager()
-    {
-        return sipSecurityManager;
-    }
+			udpListeningPoint = null;
+			tcpListeningPoint = null;
+			tlsListeningPoint = null;
+			udpJainSipProvider = null;
+			tcpJainSipProvider = null;
+			tlsJainSipProvider = null;
+			headerFactory = null;
+			messageFactory = null;
+			addressFactory = null;
+			sipFactory = null;
+			sipSecurityManager = null;
 
-    /**
-     * Initializes the SipRegistrarConnection that this class will be using.
-     *
-     * @param accountID the ID of the account that this registrar is associated
-     * with.
-     * @throws java.lang.IllegalArgumentException if one or more account
-     * properties have invalid values.
-     */
-    private void initRegistrarConnection(SipAccountID accountID)
-        throws IllegalArgumentException
-    {
-        //First init the registrar address
-        String registrarAddressStr = (String) accountID.getAccountProperties()
-            .get(ProtocolProviderFactory.SERVER_ADDRESS);
+			methodProcessors.clear();
 
-        //if there is no registrar address, parse the user_id and extract it
-        //from the domain part of the SIP URI.
-        if (registrarAddressStr == null)
-        {
-            String userID = (String) accountID.getAccountProperties()
-                .get(ProtocolProviderFactory.USER_ID);
-            registrarAddressStr = userID.substring( userID.indexOf("@")+1);
-        }
-        
-        InetAddress registrarAddress = null;
+			isInitialized = false;
+		}
+	}
 
-        try
-        {
-            registrarAddress = InetAddress.getByName(registrarAddressStr);
+	/**
+	 * Generate a tag for a FROM header or TO header. Just return a random 4
+	 * digit integer (should be enough to avoid any clashes!) Tags only need to
+	 * be unique within a call.
+	 * 
+	 * @return a string that can be used as a tag parameter.
+	 * 
+	 *         synchronized: needed for access to 'rand', else risk to generate
+	 *         same tag twice
+	 */
+	public static synchronized String generateLocalTag() {
+		return Integer.toHexString(localTagGenerator.nextInt());
+	}
 
-            // We should set here the property to indicate that the server
-            // address is validated. When we load stored accounts we check
-            // this property in order to prevent checking again the server
-            // address. And this is needed because in the case we don't have
-            // network while loading the application we still want to have our
-            // accounts loaded.
-            accountID.putProperty(
-                ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED,
-                Boolean.toString(true));
+	/**
+	 * Initializes and returns an ArrayList with a single ViaHeader containing a
+	 * localhost address usable with the specified s<tt>destination</tt>. This
+	 * ArrayList may be used when sending requests to that destination.
+	 * <p>
+	 * 
+	 * @param destination
+	 *            The address of the destination that the request using the via
+	 *            headers will be sent to.
+	 * @param srcListeningPoint
+	 *            the listening point that we will be using when accessing
+	 *            destination.
+	 * 
+	 * @return ViaHeader-s list to be used when sending requests.
+	 * @throws OperationFailedException
+	 *             code INTERNAL_ERROR if a ParseException occurs while
+	 *             initializing the array list.
+	 * 
+	 */
+	public ArrayList getLocalViaHeaders(InetAddress destination,
+			ListeningPoint srcListeningPoint) throws OperationFailedException {
+		ArrayList viaHeaders = new ArrayList();
+		try {
+			InetAddress localAddress = SipActivator
+					.getNetworkAddressManagerService()
+					.getLocalHost(destination);
+			ViaHeader viaHeader = headerFactory.createViaHeader(localAddress
+					.getHostAddress(), srcListeningPoint.getPort(),
+					srcListeningPoint.getTransport(), null);
+			viaHeaders.add(viaHeader);
+			logger.debug("generated via headers:" + viaHeader);
+			return viaHeaders;
+		} catch (ParseException ex) {
+			logger
+					.error(
+							"A ParseException occurred while creating Via Headers!",
+							ex);
+			throw new OperationFailedException(
+					"A ParseException occurred while creating Via Headers!",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		} catch (InvalidArgumentException ex) {
+			logger.error("Unable to create a via header for port "
+					+ udpListeningPoint.getPort(), ex);
+			throw new OperationFailedException(
+					"Unable to create a via header for port "
+							+ udpListeningPoint.getPort(),
+					OperationFailedException.INTERNAL_ERROR, ex);
+		}
+	}
 
-        }
-        catch (UnknownHostException ex)
-        {
-            logger.error(registrarAddressStr
-                + " appears to be an either invalid or inaccessible address: "
-                , ex);
+	/**
+	 * Initializes and returns this provider's default maxForwardsHeader field
+	 * using the value specified by MAX_FORWARDS.
+	 * 
+	 * @return an instance of a MaxForwardsHeader that can be used when sending
+	 *         requests
+	 * 
+	 * @throws OperationFailedException
+	 *             with code INTERNAL_ERROR if MAX_FORWARDS has an invalid
+	 *             value.
+	 */
+	public MaxForwardsHeader getMaxForwardsHeader()
+			throws OperationFailedException {
+		if (maxForwardsHeader == null) {
+			try {
+				maxForwardsHeader = headerFactory
+						.createMaxForwardsHeader(MAX_FORWARDS);
+				logger.debug("generated max forwards: "
+						+ maxForwardsHeader.toString());
+			} catch (InvalidArgumentException ex) {
+				throw new OperationFailedException(
+						"A problem occurred while creating MaxForwardsHeader",
+						OperationFailedException.INTERNAL_ERROR, ex);
+			}
+		}
 
-            String serverValidatedString
-                = (String) accountID.getAccountProperties()
-                    .get(ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED);
+		return maxForwardsHeader;
+	}
 
-            boolean isServerValidated = false;
-            if (serverValidatedString != null)
-                isServerValidated = new Boolean(serverValidatedString)
-                    .booleanValue();
+	/**
+	 * Retrns a Contact header containing our sip uri and therefore usable in
+	 * all but REGISTER requests. Same as calling getContactHeader(false)
+	 * 
+	 * @return a Contact header containing our sip uri
+	 */
+	public ContactHeader getContactHeader() {
+		if (this.genericContactHeader == null) {
+			try {
+				genericContactHeader = getContactHeader(sipRegistrarConnection
+						.getRegistrarAddress(), sipRegistrarConnection
+						.getRegistrarListeningPoint());
+			} catch (OperationFailedException ex) {
+				logger.error("Failed to create Contact header.", ex);
+			}
+			logger.debug("generated contactHeader:" + genericContactHeader);
+		}
+		return genericContactHeader;
+	}
 
-            // We should check here if the server address was already validated. 
-            // When we load stored accounts we want to prevent checking again the
-            // server address. This is needed because in the case we don't have
-            // network while loading the application we still want to have our
-            // accounts loaded.
-            if (serverValidatedString == null || !isServerValidated)
-            {
-                throw new IllegalArgumentException(
-                    registrarAddressStr
-                    + " appears to be an either invalid or inaccessible address: "
-                    + ex.getMessage());
-            }
-        }
+	/**
+	 * Retrns a Contact header containing a sip URI base on a localhost address
+	 * and thereforeusable in REGISTER requests only.
+	 * 
+	 * @param targetAddress
+	 *            the address of the registrar that this contact header is meant
+	 *            for.
+	 * @param srcListeningPoint
+	 *            the listening point that will be used when accessing the
+	 *            registrar.
+	 * 
+	 * @return a Contact header based upon a local inet address.
+	 * @throws OperationFailedException
+	 *             if we fail constructing the contact header.
+	 */
+	ContactHeader getContactHeader(InetAddress targetAddress,
+			ListeningPoint srcListeningPoint) throws OperationFailedException {
+		ContactHeader registrationContactHeader = null;
+		try {
+			// find the address to use with the target
+			InetAddress localAddress = SipActivator
+					.getNetworkAddressManagerService().getLocalHost(
+							targetAddress);
 
-        // If the registrar address is null we don't need to continue.
-        // If we still have problems with initializing the registrar we are
-        // telling the user. We'll enter here only if the server has been
-        // already validated (this means that the account is already created
-        // and we're trying to login, but we have no internet connection).
-        if(registrarAddress == null)
-        {
-            fireRegistrationStateChanged(
-                RegistrationState.UNREGISTERED,
-                RegistrationState.CONNECTION_FAILED,
-                RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,
-                "Invalid or inaccessible server address.");
+			SipURI contactURI = addressFactory.createSipURI(
+					((SipURI) ourSipAddress.getURI()).getUser(), localAddress
+							.getHostAddress());
 
-            return;
-        }
+			contactURI.setTransportParam(srcListeningPoint.getTransport());
+			contactURI.setPort(srcListeningPoint.getPort());
+			Address contactAddress = addressFactory.createAddress(contactURI);
 
-        //init registrar port
-        int registrarPort = ListeningPoint.PORT_5060;
+			if (ourDisplayName != null) {
+				contactAddress.setDisplayName(ourDisplayName);
+			}
+			registrationContactHeader = headerFactory
+					.createContactHeader(contactAddress);
+			logger
+					.debug("generated contactHeader:"
+							+ registrationContactHeader);
+		} catch (ParseException ex) {
+			logger
+					.error(
+							"A ParseException occurred while creating From Header!",
+							ex);
+			throw new OperationFailedException(
+					"A ParseException occurred while creating From Header!",
+					OperationFailedException.INTERNAL_ERROR, ex);
+		}
+		return registrationContactHeader;
+	}
 
-        String registrarPortStr = (String) accountID.getAccountProperties()
-            .get(ProtocolProviderFactory.SERVER_PORT);
+	/**
+	 * Returns the AddressFactory used to create URLs ans Address objects.
+	 * 
+	 * @return the AddressFactory used to create URLs ans Address objects.
+	 */
+	public AddressFactory getAddressFactory() {
+		return addressFactory;
+	}
 
-        if(registrarPortStr != null && registrarPortStr.length() > 0)
-        {
-            try
-            {
-                registrarPort = Integer.parseInt(registrarPortStr);
-            }
-            catch (NumberFormatException ex)
-            {
-                logger.error(
-                    registrarPortStr
-                    + " is not a valid port value. Expected an integer"
-                    , ex);
-            }
+	/**
+	 * Returns the HeaderFactory used to create SIP message headers.
+	 * 
+	 * @return the HeaderFactory used to create SIP message headers.
+	 */
+	public HeaderFactory getHeaderFactory() {
+		return headerFactory;
+	}
 
-            if ( registrarPort > NetworkUtils.MAX_PORT_NUMBER)
-            {
-                throw new IllegalArgumentException(registrarPort
-                    + " is larger than " + NetworkUtils.MAX_PORT_NUMBER
-                    + " and does not therefore represent a valid port nubmer.");
-            }
-        }
+	/**
+	 * Returns the Message Factory used to create SIP messages.
+	 * 
+	 * @return the Message Factory used to create SIP messages.
+	 */
+	public MessageFactory getMessageFactory() {
+		return messageFactory;
+	}
 
-        //registrar transport
-        String registrarTransport = (String) accountID.getAccountProperties()
-            .get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
+	/**
+	 * Returns the sipStack instance that handles SIP communications.
+	 * 
+	 * @return the sipStack instance that handles SIP communications.
+	 */
+	public SipStack getJainSipStack() {
+		return jainSipStack;
+	}
 
-        if(registrarTransport != null && registrarTransport.length() > 0)
-        {
-            if( ! registrarTransport.equals(ListeningPoint.UDP)
-                && !registrarTransport.equals(ListeningPoint.TCP)
-                && !registrarTransport.equals(ListeningPoint.TLS))
-            {
-                throw new IllegalArgumentException(registrarTransport
-                    + " is not a valid transport protocol. Transport must be "
-                    +"left blanc or set to TCP, UDP or TLS.");
-            }
-        }
-        else
-        {
-            registrarTransport = ListeningPoint.UDP;
-        }
+	/**
+	 * Returns the default listening point that we use for communication over
+	 * <tt>transport</tt>.
+	 * 
+	 * @param transport
+	 *            the transport that the returned listening point needs to
+	 *            support.
+	 * 
+	 * @return the default listening point that we use for communication over
+	 *         <tt>transport</tt> or null if no such transport is supported.
+	 */
+	public ListeningPoint getListeningPoint(String transport) {
+		if (transport.equalsIgnoreCase(ListeningPoint.UDP)) {
+			return udpListeningPoint;
+		} else if (transport.equalsIgnoreCase(ListeningPoint.TCP)) {
+			return tcpListeningPoint;
+		} else if (transport.equalsIgnoreCase(ListeningPoint.TLS)) {
+			return tlsListeningPoint;
+		}
+		return null;
+	}
 
-        //init expiration timeout
-        int expires = SipRegistrarConnection.DEFAULT_REGISTRATION_EXPIRATION;
+	/**
+	 * Returns the default jain sip provider that we use for communication over
+	 * <tt>transport</tt>.
+	 * 
+	 * @param transport
+	 *            the transport that the returned provider needs to support.
+	 * 
+	 * @return the default jain sip provider that we use for communication over
+	 *         <tt>transport</tt> or null if no such transport is supported.
+	 */
+	public SipProvider getJainSipProvider(String transport) {
+		if (transport.equalsIgnoreCase(ListeningPoint.UDP)) {
+			return udpJainSipProvider;
+		} else if (transport.equalsIgnoreCase(ListeningPoint.TCP)) {
+			return tcpJainSipProvider;
+		} else if (transport.equalsIgnoreCase(ListeningPoint.TLS)) {
+			return tlsJainSipProvider;
+		}
+		return null;
+	}
 
-        String expiresStr = SipActivator.getConfigurationService().getString(
-            REGISTRATION_EXPIRATION);
+	/**
+	 * Reurns the currently valid sip security manager that everyone should use
+	 * to authenticate SIP Requests.
+	 * 
+	 * @return the currently valid instace of a SipSecurityManager that everyone
+	 *         sould use to authenticate SIP Requests.
+	 */
+	public SipSecurityManager getSipSecurityManager() {
+		return sipSecurityManager;
+	}
 
-        if(expiresStr != null && expiresStr.length() > 0)
-        {
-            try
-            {
-                expires = Integer.parseInt(expiresStr);
-            }
-            catch (NumberFormatException ex)
-            {
-                logger.error(
-                    expiresStr
-                    + " is not a valid expires  value. Expexted an integer"
-                    , ex);
-            }
-        }
+	/**
+	 * Initializes the SipRegistrarConnection that this class will be using.
+	 * 
+	 * @param accountID
+	 *            the ID of the account that this registrar is associated with.
+	 * @throws java.lang.IllegalArgumentException
+	 *             if one or more account properties have invalid values.
+	 */
+	private void initRegistrarConnection(SipAccountID accountID)
+			throws IllegalArgumentException {
+		// First init the registrar address
+		String registrarAddressStr = (String) accountID.getAccountProperties()
+				.get(ProtocolProviderFactory.SERVER_ADDRESS);
 
-        //Initialize our connection with the registrar
-        try
-        {
-            this.sipRegistrarConnection = new SipRegistrarConnection(
-                registrarAddress
-                , registrarPort
-                , registrarTransport
-                , expires
-                , this);
-            
-            //determine whether we should be using route headers or not
-            String useRouteString = (String) accountID.getAccountProperties()
-                .get(REGISTERS_USE_ROUTE);
-            
-            boolean useRoute = false;
-            
-            if (useRouteString != null)
-                useRoute = new Boolean(useRouteString).booleanValue();
-            
-            this.sipRegistrarConnection.setRouteHeaderEnabled(useRoute);
-        }
-        catch (ParseException ex)
-        {
-            //this really shouldn't happen as we're using InetAddress-es
-            logger.error("Failed to create a registrar connection with "
-                +registrarAddress.getHostAddress()
-                , ex);
-            throw new IllegalArgumentException(
-                "Failed to create a registrar connection with "
-                + registrarAddress.getHostAddress() + ": "
-                + ex.getMessage());
-        }
+		// if there is no registrar address, parse the user_id and extract it
+		// from the domain part of the SIP URI.
+		if (registrarAddressStr == null) {
+			String userID = (String) accountID.getAccountProperties().get(
+					ProtocolProviderFactory.USER_ID);
+			registrarAddressStr = userID.substring(userID.indexOf("@") + 1);
+		}
 
-        //initialize our OPTIONS handler
-        ClientCapabilities capabilities = new ClientCapabilities(this);
-    }
+		InetAddress registrarAddress = null;
 
-    /**
-     * Returns the SIP Address (Display Name <user@server.net>) that this
-     * account is created for.
-     * @return Address
-     */
-    public Address getOurSipAddress()
-    {
-        return ourSipAddress;
-    }
+		try {
+			registrarAddress = InetAddress.getByName(registrarAddressStr);
 
-    /**
-     * Extracts all properties concerning the usage of an outbound proxy for
-     * this account.
-     * @param accountID the account whose outbound proxy we are currently
-     * initializing.
-     * @param jainSipProperties the properties that we will be passing to the
-     * jain sip stack when initialize it (that's where we'll put all proxy
-     * properties).
-     */
-    private void initOutboundProxy(SipAccountID accountID,
-                                   Hashtable jainSipProperties)
-    {
-        //First init the proxy address
-        String proxyAddressStr = (String) accountID.getAccountProperties()
-            .get(ProtocolProviderFactory.PROXY_ADDRESS);
+			// We should set here the property to indicate that the server
+			// address is validated. When we load stored accounts we check
+			// this property in order to prevent checking again the server
+			// address. And this is needed because in the case we don't have
+			// network while loading the application we still want to have our
+			// accounts loaded.
+			accountID.putProperty(
+					ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED, Boolean
+							.toString(true));
 
-        InetAddress proxyAddress = null;
+		} catch (UnknownHostException ex) {
+			logger
+					.error(
+							registrarAddressStr
+									+ " appears to be an either invalid or inaccessible address: ",
+							ex);
 
-        try
-        {
-            // first check for srv records exists
-            try
-            {
-                String lookupStr = null;
+			String serverValidatedString = (String) accountID
+					.getAccountProperties().get(
+							ProtocolProviderFactory.SERVER_ADDRESS_VALIDATED);
 
-                String proxyTransport = (String) accountID.getAccountProperties()
-                            .get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
-                
-                if(proxyTransport == null)
-                    proxyTransport = getDefaultTransport();
-                
-                if(proxyTransport.equalsIgnoreCase(ListeningPoint.UDP))
-                    lookupStr = "_sip._udp." + proxyAddressStr;
-                else if(proxyTransport.equalsIgnoreCase(ListeningPoint.TCP))
-                    lookupStr = "_sip._tcp." + proxyAddressStr;
-                else if(proxyTransport.equalsIgnoreCase(ListeningPoint.TLS))
-                    lookupStr = "_sips._tcp." + proxyAddressStr;
+			boolean isServerValidated = false;
+			if (serverValidatedString != null)
+				isServerValidated = new Boolean(serverValidatedString)
+						.booleanValue();
 
-                InetSocketAddress hosts[] = NetworkUtils.getSRVRecords(lookupStr);
+			// We should check here if the server address was already validated.
+			// When we load stored accounts we want to prevent checking again
+			// the
+			// server address. This is needed because in the case we don't have
+			// network while loading the application we still want to have our
+			// accounts loaded.
+			if (serverValidatedString == null || !isServerValidated) {
+				throw new IllegalArgumentException(
+						registrarAddressStr
+								+ " appears to be an either invalid or inaccessible address: "
+								+ ex.getMessage());
+			}
+		}
 
-                if(hosts != null && hosts.length > 0)
-                {
-                    logger.trace("Will set server address from SRV records "
-                       + hosts[0]);
+		// If the registrar address is null we don't need to continue.
+		// If we still have problems with initializing the registrar we are
+		// telling the user. We'll enter here only if the server has been
+		// already validated (this means that the account is already created
+		// and we're trying to login, but we have no internet connection).
+		if (registrarAddress == null) {
+			fireRegistrationStateChanged(RegistrationState.UNREGISTERED,
+					RegistrationState.CONNECTION_FAILED,
+					RegistrationStateChangeEvent.REASON_SERVER_NOT_FOUND,
+					"Invalid or inaccessible server address.");
 
-                    proxyAddressStr = hosts[0].getHostName();
-                }
-            }
-            catch (Exception ex)
-            {
-                // no SRV record or error looking for it
-            }
+			return;
+		}
 
-            proxyAddress = InetAddress.getByName(proxyAddressStr);
+		// init registrar port
+		int registrarPort = ListeningPoint.PORT_5060;
 
-            // We should set here the property to indicate that the proxy
-            // address is validated. When we load stored accounts we check
-            // this property in order to prevent checking again the proxy
-            // address. this is needed because in the case we don't have
-            // network while loading the application we still want to have
-            // our accounts loaded.
-            accountID.putProperty(
-                ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED,
-                Boolean.toString(true));
-        }
-        catch (UnknownHostException ex)
-        {
-            logger.error(proxyAddressStr
-                + " appears to be an either invalid or inaccessible address"
-                , ex);
+		String registrarPortStr = (String) accountID.getAccountProperties()
+				.get(ProtocolProviderFactory.SERVER_PORT);
 
-            String proxyValidatedString = (String) accountID
-            .getAccountProperties().get(
-                ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED);
+		if (registrarPortStr != null && registrarPortStr.length() > 0) {
+			try {
+				registrarPort = Integer.parseInt(registrarPortStr);
+			} catch (NumberFormatException ex) {
+				logger
+						.error(
+								registrarPortStr
+										+ " is not a valid port value. Expected an integer",
+								ex);
+			}
 
-            boolean isProxyValidated = false;
-            if (proxyValidatedString != null)
-                isProxyValidated
-                    = new Boolean(proxyValidatedString).booleanValue();
+			if (registrarPort > NetworkUtils.MAX_PORT_NUMBER) {
+				throw new IllegalArgumentException(
+						registrarPort
+								+ " is larger than "
+								+ NetworkUtils.MAX_PORT_NUMBER
+								+ " and does not therefore represent a valid port nubmer.");
+			}
+		}
 
-            // We should check here if the proxy address was already validated. 
-            // When we load stored accounts we want to prevent checking again the
-            // proxy address. This is needed because in the case we don't have
-            // network while loading the application we still want to have our
-            // accounts loaded.
-            if (proxyValidatedString == null || !isProxyValidated)
-            {
-                throw new IllegalArgumentException(
-                    proxyAddressStr
-                    + " appears to be an either invalid or inaccessible address "
-                    + ex.getMessage());
-            }
-        }
+		// registrar transport
+		String registrarTransport = (String) accountID.getAccountProperties()
+				.get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
 
-        // Return if no proxy is specified or if the proxyAddress is null.
-        if(proxyAddressStr == null
-                || proxyAddressStr.length() == 0
-                || proxyAddress == null)
-        {
-            return;
-        }
+		if (registrarTransport != null && registrarTransport.length() > 0) {
+			if (!registrarTransport.equals(ListeningPoint.UDP)
+					&& !registrarTransport.equals(ListeningPoint.TCP)
+					&& !registrarTransport.equals(ListeningPoint.TLS)) {
+				throw new IllegalArgumentException(
+						registrarTransport
+								+ " is not a valid transport protocol. Transport must be "
+								+ "left blanc or set to TCP, UDP or TLS.");
+			}
+		} else {
+			registrarTransport = ListeningPoint.UDP;
+		}
 
-        //init proxy port
-        int proxyPort = ListeningPoint.PORT_5060;
+		// init expiration timeout
+		int expires = SipRegistrarConnection.DEFAULT_REGISTRATION_EXPIRATION;
 
-        String proxyPortStr = (String) accountID.getAccountProperties()
-            .get(ProtocolProviderFactory.PROXY_PORT);
+		String expiresStr = SipActivator.getConfigurationService().getString(
+				REGISTRATION_EXPIRATION);
 
-        if (proxyPortStr != null && proxyPortStr.length() > 0)
-        {
-            try
-            {
-                proxyPort = Integer.parseInt(proxyPortStr);
-            }
-            catch (NumberFormatException ex)
-            {
-                logger.error(
-                    proxyPortStr
-                    + " is not a valid port value. Expected an integer"
-                    , ex);
-            }
+		if (expiresStr != null && expiresStr.length() > 0) {
+			try {
+				expires = Integer.parseInt(expiresStr);
+			} catch (NumberFormatException ex) {
+				logger
+						.error(
+								expiresStr
+										+ " is not a valid expires  value. Expexted an integer",
+								ex);
+			}
+		}
 
-            if (proxyPort > NetworkUtils.MAX_PORT_NUMBER)
-            {
-                throw new IllegalArgumentException(proxyPort
-                    + " is larger than " +
-                    NetworkUtils.MAX_PORT_NUMBER
-                    +
-                    " and does not therefore represent a valid port nubmer.");
-            }
-        }
+		// Initialize our connection with the registrar
+		try {
+			this.sipRegistrarConnection = new SipRegistrarConnection(
+					registrarAddress, registrarPort, registrarTransport,
+					expires, this);
 
-        //proxy transport
-        String proxyTransport = (String) accountID.getAccountProperties()
-            .get(ProtocolProviderFactory.PREFERRED_TRANSPORT);
+			// determine whether we should be using route headers or not
+			String useRouteString = (String) accountID.getAccountProperties()
+					.get(REGISTERS_USE_ROUTE);
 
-        if (proxyTransport != null && proxyTransport.length() > 0)
-        {
-            if (!proxyTransport.equals(ListeningPoint.UDP)
-                && !proxyTransport.equals(ListeningPoint.TCP)
-                && !proxyTransport.equals(ListeningPoint.TLS))
-            {
-                throw new IllegalArgumentException(proxyTransport
-                    + " is not a valid transport protocol. Transport must be "
-                    + "left blanc or set to TCP, UDP or TLS.");
-            }
-        }
-        else
-        {
-            proxyTransport = ListeningPoint.UDP;
-        }
+			boolean useRoute = false;
 
-        StringBuffer proxyStringBuffer
-            = new StringBuffer(proxyAddress.getHostAddress());
+			if (useRouteString != null)
+				useRoute = new Boolean(useRouteString).booleanValue();
 
-        if(proxyAddress instanceof Inet6Address)
-        {
-            proxyStringBuffer.insert(0, '[');
-            proxyStringBuffer.append(']');
-        }
+			this.sipRegistrarConnection.setRouteHeaderEnabled(useRoute);
+		} catch (ParseException ex) {
+			// this really shouldn't happen as we're using InetAddress-es
+			logger.error("Failed to create a registrar connection with "
+					+ registrarAddress.getHostAddress(), ex);
+			throw new IllegalArgumentException(
+					"Failed to create a registrar connection with "
+							+ registrarAddress.getHostAddress() + ": "
+							+ ex.getMessage());
+		}
 
-        proxyStringBuffer.append(':');
-        proxyStringBuffer.append(Integer.toString(proxyPort));
-        proxyStringBuffer.append('/');
-        proxyStringBuffer.append(proxyTransport);
+		// initialize our OPTIONS handler
+		ClientCapabilities capabilities = new ClientCapabilities(this);
+	}
 
-        //done parsing. init properties.
-        jainSipProperties.put(  JSPNAME_OUTBOUND_PROXY,
-                                proxyStringBuffer.toString());
+	/**
+	 * Returns the SIP Address (Display Name <user@server.net>) that this
+	 * account is created for.
+	 * 
+	 * @return Address
+	 */
+	public Address getOurSipAddress() {
+		return ourSipAddress;
+	}
 
-        //store a reference to our sip proxy so that we can use it when
-        //constructing via and contact headers.
-        this.outboundProxySocketAddress
-            = new InetSocketAddress(proxyAddress, proxyPort);
-        this.outboundProxyTransport = proxyTransport;
-    }
+	/**
+	 * Extracts all properties concerning the usage of an outbound proxy for
+	 * this account.
+	 * 
+	 * @param accountID
+	 *            the account whose outbound proxy we are currently
+	 *            initializing.
+	 * @param jainSipProperties
+	 *            the properties that we will be passing to the jain sip stack
+	 *            when initialize it (that's where we'll put all proxy
+	 *            properties).
+	 */
+	private void initOutboundProxy(SipAccountID accountID,
+			Hashtable jainSipProperties) {
+		// First init the proxy address
+		String proxyAddressStr = (String) accountID.getAccountProperties().get(
+				ProtocolProviderFactory.PROXY_ADDRESS);
 
-    /**
-     * Registers <tt>methodProcessor</tt> in the <tt>methorProcessors</tt>
-     * table so that it would receives all messages in a transaction initiated
-     * by a <tt>method</tt> request. If any previous processors exist for the
-     * same method, they will be replaced by this one.
-     *
-     * @param method a String representing the SIP method that we're registering
-     * the processor for (e.g. INVITE, REGISTER, or SUBSCRIBE).
-     * @param methodProcessor a <tt>SipListener</tt> implementation that would
-     * handle all messages received within a <tt>method</tt> transaction.
-     */
-    public void registerMethodProcessor(String      method,
-                                        SipListener methodProcessor)
-    {
-        this.methodProcessors.put(method, methodProcessor);
-    }
+		InetAddress proxyAddress = null;
 
-    /**
-     * Unregisters <tt>methodProcessor</tt> from the <tt>methorProcessors</tt>
-     * table so that it won't receive further messages in a transaction
-     * initiated by a <tt>method</tt> request.
-     *
-     * @param method the name of the method whose processor we'd like to
-     * unregister.
-     */
-    public void unregisterMethodProcessor(String      method)
-    {
-            this.methodProcessors.remove(method);
-    }
+		try {
+			// first check for srv records exists
+			try {
+				String lookupStr = null;
 
-    /**
-     * Returns the transport that we should use if we have no clear idea of our
-     * destination's preferred transport. The method would first check if
-     * we are running behind an outbound proxy and if so return its transport.
-     * If no outbound proxy is set, the method would check the contents of the
-     * DEFAULT_TRANSPORT property and return it if not null. Otherwise the
-     * method would return UDP;
-     *
-     * @return The first non null password of the following: a) the transport
-     * of our outbound proxy, b) the transport specified by the
-     * DEFAULT_TRANSPORT property, c) UDP.
-     */
-    public String getDefaultTransport()
-    {
-        if(outboundProxySocketAddress != null
-            && outboundProxyTransport != null)
-        {
-            return outboundProxyTransport;
-        }
-        else
-        {
-            String userSpecifiedDefaultTransport
-                = SipActivator.getConfigurationService()
-                    .getString(DEFAULT_TRANSPORT);
+				String proxyTransport = (String) accountID
+						.getAccountProperties().get(
+								ProtocolProviderFactory.PREFERRED_TRANSPORT);
 
-            if(userSpecifiedDefaultTransport != null)
-            {
-                return userSpecifiedDefaultTransport;
-            }
-            else
-                return ListeningPoint.UDP;
-        }
-    }
+				if (proxyTransport == null)
+					proxyTransport = getDefaultTransport();
 
-    /**
-     * Returns the provider that corresponds to the transport returned by
-     * getDefaultTransport(). Equivalent to calling
-     * getJainSipProvider(getDefaultTransport())
-     *
-     * @return the Jain SipProvider that corresponds to the transport returned
-     * by getDefaultTransport().
-     */
-    public SipProvider getDefaultJainSipProvider()
-    {
-        return getJainSipProvider(getDefaultTransport());
-    }
+				if (proxyTransport.equalsIgnoreCase(ListeningPoint.UDP))
+					lookupStr = "_sip._udp." + proxyAddressStr;
+				else if (proxyTransport.equalsIgnoreCase(ListeningPoint.TCP))
+					lookupStr = "_sip._tcp." + proxyAddressStr;
+				else if (proxyTransport.equalsIgnoreCase(ListeningPoint.TLS))
+					lookupStr = "_sips._tcp." + proxyAddressStr;
 
-    /**
-     * Returns the listening point that corresponds to the transport returned by
-     * getDefaultTransport(). Equivalent to calling
-     * getListeningPoint(getDefaultTransport())
-     *
-     * @return the Jain SipProvider that corresponds to the transport returned
-     * by getDefaultTransport().
-     */
-    public ListeningPoint getDefaultListeningPoint()
-    {
-        return getListeningPoint(getDefaultTransport());
-    }
+				InetSocketAddress hosts[] = NetworkUtils
+						.getSRVRecords(lookupStr);
 
-    /**
-     * Returns the display name string that the user has set as a display name
-     * for this account.
-     *
-     * @return the display name string that the user has set as a display name
-     * for this account.
-     */
-    public String getOurDisplayName()
-    {
-        return ourDisplayName;
-    }
+				if (hosts != null && hosts.length > 0) {
+					logger.trace("Will set server address from SRV records "
+							+ hosts[0]);
 
-    /**
-     * Returns a User Agent header that could be used for signing our requests.
-     *
-     * @return a <tt>UserAgentHeader</tt> that could be used for signing our
-     * requests.
-     */
-    public UserAgentHeader getSipCommUserAgentHeader()
-    {
-        if(userAgentHeader == null)
-        {
-            try
-            {
-                List userAgentTokens = new LinkedList();
-                userAgentTokens.add("SIP Communicator");
-                userAgentTokens.add("1.0");
-                String dateString
-                    = new Date().toString().replace(' ', '_').replace(':', '-');
-                userAgentTokens.add("CVS-" + dateString);
+					proxyAddressStr = hosts[0].getHostName();
+				}
+			} catch (Exception ex) {
+				// no SRV record or error looking for it
+			}
 
-                userAgentHeader
-                    = this.headerFactory.createUserAgentHeader(userAgentTokens);
-            }
-            catch (ParseException ex)
-            {
-                //shouldn't happen
-                return null;
-            }
-        }
-        return userAgentHeader;
-    }
+			proxyAddress = InetAddress.getByName(proxyAddressStr);
 
-    /**
-     * Generates a ToTag and attaches it to the to header of <tt>response</tt>.
-     *
-     * @param response the response that is to get the ToTag.
-     * @param containingDialog the Dialog instance that is to extract a unique
-     * Tag value (containingDialog.hashCode())
-     */
-    public void attachToTag(Response response, Dialog containingDialog)
-    {
-        ToHeader to = (ToHeader) response.getHeader(ToHeader.NAME);
-        if (to == null) {
-            logger.debug("Strange ... no to tag in response:" + response);
-            return;
-        }
+			// We should set here the property to indicate that the proxy
+			// address is validated. When we load stored accounts we check
+			// this property in order to prevent checking again the proxy
+			// address. this is needed because in the case we don't have
+			// network while loading the application we still want to have
+			// our accounts loaded.
+			accountID.putProperty(
+					ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED, Boolean
+							.toString(true));
+		} catch (UnknownHostException ex) {
+			logger
+					.error(
+							proxyAddressStr
+									+ " appears to be an either invalid or inaccessible address",
+							ex);
 
-        if(containingDialog.getLocalTag() != null)
-        {
-            logger.debug("We seem to already have a tag in this dialog. "
-                         +"Returning");
-            return;
-        }
+			String proxyValidatedString = (String) accountID
+					.getAccountProperties().get(
+							ProtocolProviderFactory.PROXY_ADDRESS_VALIDATED);
 
-        try
-        {
-            if (to.getTag() == null || to.getTag().trim().length() == 0)
-            {
+			boolean isProxyValidated = false;
+			if (proxyValidatedString != null)
+				isProxyValidated = new Boolean(proxyValidatedString)
+						.booleanValue();
 
-                String toTag = generateLocalTag();
+			// We should check here if the proxy address was already validated.
+			// When we load stored accounts we want to prevent checking again
+			// the
+			// proxy address. This is needed because in the case we don't have
+			// network while loading the application we still want to have our
+			// accounts loaded.
+			if (proxyValidatedString == null || !isProxyValidated) {
+				throw new IllegalArgumentException(
+						proxyAddressStr
+								+ " appears to be an either invalid or inaccessible address "
+								+ ex.getMessage());
+			}
+		}
 
-                logger.debug("generated to tag: " + toTag);
-                to.setTag(toTag);
-            }
-        }
-        catch (ParseException ex)
-        {
-            //a parse exception here mean an internal error so we can only log
-            logger.error("Failed to attach a to tag to an outgoing response."
-                         , ex);
-        }
-    }
+		// Return if no proxy is specified or if the proxyAddress is null.
+		if (proxyAddressStr == null || proxyAddressStr.length() == 0
+				|| proxyAddress == null) {
+			return;
+		}
 
-    /**
-     * Returns a List of Strings corresponding to all methods that we have a
-     * processor for.
-     * @return a List of methods that we support.
-     */
-    public List getSupportedMethods()
-    {
-        return new ArrayList(methodProcessors.keySet());
-    }
+		// init proxy port
+		int proxyPort = ListeningPoint.PORT_5060;
 
-    private class ShutdownUnregistrationBlockListener
-        implements RegistrationStateChangeListener
-    {
-            public List collectedNewStates = new LinkedList();
+		String proxyPortStr = (String) accountID.getAccountProperties().get(
+				ProtocolProviderFactory.PROXY_PORT);
 
-            /**
-             * The method would simply register all received events so that they
-             * could be available for later inspection by the unit tests. In the
-             * case where a registraiton event notifying us of a completed
-             * registration is seen, the method would call notifyAll().
-             *
-             * @param evt ProviderStatusChangeEvent the event describing the status
-             * change.
-             */
-            public void registrationStateChanged(RegistrationStateChangeEvent evt)
-            {
-                logger.debug("Received a RegistrationStateChangeEvent: " + evt);
+		if (proxyPortStr != null && proxyPortStr.length() > 0) {
+			try {
+				proxyPort = Integer.parseInt(proxyPortStr);
+			} catch (NumberFormatException ex) {
+				logger
+						.error(
+								proxyPortStr
+										+ " is not a valid port value. Expected an integer",
+								ex);
+			}
 
-                collectedNewStates.add(evt.getNewState());
+			if (proxyPort > NetworkUtils.MAX_PORT_NUMBER) {
+				throw new IllegalArgumentException(
+						proxyPort
+								+ " is larger than "
+								+ NetworkUtils.MAX_PORT_NUMBER
+								+ " and does not therefore represent a valid port nubmer.");
+			}
+		}
 
-                if (evt.getNewState().equals(RegistrationState.UNREGISTERED))
-                {
-                    logger.debug(
-                        "We're unregistered and will notify those who wait");
-                    synchronized (this)
-                    {
-                        notifyAll();
-                    }
-                }
-            }
+		// proxy transport
+		String proxyTransport = (String) accountID.getAccountProperties().get(
+				ProtocolProviderFactory.PREFERRED_TRANSPORT);
 
-            /**
-             * Blocks until an event notifying us of the awaited state change is
-             * received or until waitFor miliseconds pass (whichever happens first).
-             *
-             * @param waitFor the number of miliseconds that we should be waiting
-             * for an event before simply bailing out.
-             */
-            public void waitForEvent(long waitFor)
-            {
-                logger.trace("Waiting for a "
-                             +"RegistrationStateChangeEvent.UNREGISTERED");
+		if (proxyTransport != null && proxyTransport.length() > 0) {
+			if (!proxyTransport.equals(ListeningPoint.UDP)
+					&& !proxyTransport.equals(ListeningPoint.TCP)
+					&& !proxyTransport.equals(ListeningPoint.TLS)) {
+				throw new IllegalArgumentException(
+						proxyTransport
+								+ " is not a valid transport protocol. Transport must be "
+								+ "left blanc or set to TCP, UDP or TLS.");
+			}
+		} else {
+			proxyTransport = ListeningPoint.UDP;
+		}
 
-                synchronized (this)
-                {
-                    if (collectedNewStates.contains(
-                            RegistrationState.UNREGISTERED))
-                    {
-                        logger.trace("Event already received. "
-                                     + collectedNewStates);
-                        return;
-                    }
+		StringBuffer proxyStringBuffer = new StringBuffer(proxyAddress
+				.getHostAddress());
 
-                    try
-                    {
-                        wait(waitFor);
+		if (proxyAddress instanceof Inet6Address) {
+			proxyStringBuffer.insert(0, '[');
+			proxyStringBuffer.append(']');
+		}
 
-                        if (collectedNewStates.size() > 0)
-                            logger.trace(
-                                "Received a RegistrationStateChangeEvent.");
-                        else
-                            logger.trace(
-                                "No RegistrationStateChangeEvent received for "
-                                + waitFor + "ms.");
+		proxyStringBuffer.append(':');
+		proxyStringBuffer.append(Integer.toString(proxyPort));
+		proxyStringBuffer.append('/');
+		proxyStringBuffer.append(proxyTransport);
 
-                    }
-                    catch (InterruptedException ex)
-                    {
-                        logger.debug(
-                            "Interrupted while waiting for a "
-                            +"RegistrationStateChangeEvent"
-                            , ex);
-                    }
-                }
-            }
-    }
+		// done parsing. init properties.
+		jainSipProperties.put(JSPNAME_OUTBOUND_PROXY, proxyStringBuffer
+				.toString());
 
-    /**
-     * Returns the sip protocol icon.
-     * @return the sip protocol icon
-     */
-    public ProtocolIcon getProtocolIcon()
-    {
-        return protocolIcon;
-    }
+		// store a reference to our sip proxy so that we can use it when
+		// constructing via and contact headers.
+		this.outboundProxySocketAddress = new InetSocketAddress(proxyAddress,
+				proxyPort);
+		this.outboundProxyTransport = proxyTransport;
+	}
 
-    /**
-     * Returns the current instance of <tt>SipStatusEnum</tt>.
-     * 
-     * @return the current instance of <tt>SipStatusEnum</tt>.
-     */
-    SipStatusEnum getSipStatusEnum()
-    {
-        return sipStatusEnum;
-    }
-    /**
-     * Returns the current instance of <tt>SipRegistrarConnection</tt>.
-     * @return SipRegistrarConnection
-     */
-    SipRegistrarConnection getRegistrarConnection()
-    {
-        return sipRegistrarConnection;
-    }
+	/**
+	 * Registers <tt>methodProcessor</tt> in the <tt>methorProcessors</tt> table
+	 * so that it would receives all messages in a transaction initiated by a
+	 * <tt>method</tt> request.
+	 * 
+	 * @param method
+	 *            a String representing the SIP method that we're registering
+	 *            the processor for (e.g. INVITE, REGISTER, or SUBSCRIBE).
+	 * @param methodProcessor
+	 *            a <tt>SipListener</tt> implementation that would handle all
+	 *            messages received within a <tt>method</tt> transaction.
+	 */
+	public void registerMethodProcessor(String method,
+			SipListener methodProcessor) {
+		List<SipListener> sipListeners = this.methodProcessors.get(method);
+		if (sipListeners == null)
+			sipListeners = new ArrayList<SipListener>();
+		sipListeners.add(methodProcessor);
+		this.methodProcessors.put(method, sipListeners);
+	}
+
+	/**
+	 * Unregisters <tt>methodProcessor</tt> from the <tt>methorProcessors</tt>
+	 * table so that it won't receive further messages in a transaction
+	 * initiated by a <tt>method</tt> request.
+	 * 
+	 * @param method
+	 *            the name of the method whose processor we'd like to
+	 *            unregister.
+	 */
+	public void unregisterMethodProcessor(String method) {
+		this.methodProcessors.remove(method);
+	}
+
+	/**
+	 * Returns the transport that we should use if we have no clear idea of our
+	 * destination's preferred transport. The method would first check if we are
+	 * running behind an outbound proxy and if so return its transport. If no
+	 * outbound proxy is set, the method would check the contents of the
+	 * DEFAULT_TRANSPORT property and return it if not null. Otherwise the
+	 * method would return UDP;
+	 * 
+	 * @return The first non null password of the following: a) the transport of
+	 *         our outbound proxy, b) the transport specified by the
+	 *         DEFAULT_TRANSPORT property, c) UDP.
+	 */
+	public String getDefaultTransport() {
+		if (outboundProxySocketAddress != null
+				&& outboundProxyTransport != null) {
+			return outboundProxyTransport;
+		} else {
+			String userSpecifiedDefaultTransport = SipActivator
+					.getConfigurationService().getString(DEFAULT_TRANSPORT);
+
+			if (userSpecifiedDefaultTransport != null) {
+				return userSpecifiedDefaultTransport;
+			} else
+				return ListeningPoint.UDP;
+		}
+	}
+
+	/**
+	 * Returns the provider that corresponds to the transport returned by
+	 * getDefaultTransport(). Equivalent to calling
+	 * getJainSipProvider(getDefaultTransport())
+	 * 
+	 * @return the Jain SipProvider that corresponds to the transport returned
+	 *         by getDefaultTransport().
+	 */
+	public SipProvider getDefaultJainSipProvider() {
+		return getJainSipProvider(getDefaultTransport());
+	}
+
+	/**
+	 * Returns the listening point that corresponds to the transport returned by
+	 * getDefaultTransport(). Equivalent to calling
+	 * getListeningPoint(getDefaultTransport())
+	 * 
+	 * @return the Jain SipProvider that corresponds to the transport returned
+	 *         by getDefaultTransport().
+	 */
+	public ListeningPoint getDefaultListeningPoint() {
+		return getListeningPoint(getDefaultTransport());
+	}
+
+	/**
+	 * Returns the display name string that the user has set as a display name
+	 * for this account.
+	 * 
+	 * @return the display name string that the user has set as a display name
+	 *         for this account.
+	 */
+	public String getOurDisplayName() {
+		return ourDisplayName;
+	}
+
+	/**
+	 * Returns a User Agent header that could be used for signing our requests.
+	 * 
+	 * @return a <tt>UserAgentHeader</tt> that could be used for signing our
+	 *         requests.
+	 */
+	public UserAgentHeader getSipCommUserAgentHeader() {
+		if (userAgentHeader == null) {
+			try {
+				List userAgentTokens = new LinkedList();
+				userAgentTokens.add("SIP Communicator");
+				userAgentTokens.add("1.0");
+				String dateString = new Date().toString().replace(' ', '_')
+						.replace(':', '-');
+				userAgentTokens.add("CVS-" + dateString);
+
+				userAgentHeader = this.headerFactory
+						.createUserAgentHeader(userAgentTokens);
+			} catch (ParseException ex) {
+				// shouldn't happen
+				return null;
+			}
+		}
+		return userAgentHeader;
+	}
+
+	/**
+	 * Generates a ToTag and attaches it to the to header of <tt>response</tt>.
+	 * 
+	 * @param response
+	 *            the response that is to get the ToTag.
+	 * @param containingDialog
+	 *            the Dialog instance that is to extract a unique Tag value
+	 *            (containingDialog.hashCode())
+	 */
+	public void attachToTag(Response response, Dialog containingDialog) {
+		ToHeader to = (ToHeader) response.getHeader(ToHeader.NAME);
+		if (to == null) {
+			logger.debug("Strange ... no to tag in response:" + response);
+			return;
+		}
+
+		if (containingDialog.getLocalTag() != null) {
+			logger.debug("We seem to already have a tag in this dialog. "
+					+ "Returning");
+			return;
+		}
+
+		try {
+			if (to.getTag() == null || to.getTag().trim().length() == 0) {
+
+				String toTag = generateLocalTag();
+
+				logger.debug("generated to tag: " + toTag);
+				to.setTag(toTag);
+			}
+		} catch (ParseException ex) {
+			// a parse exception here mean an internal error so we can only log
+			logger.error("Failed to attach a to tag to an outgoing response.",
+					ex);
+		}
+	}
+
+	/**
+	 * Returns a List of Strings corresponding to all methods that we have a
+	 * processor for.
+	 * 
+	 * @return a List of methods that we support.
+	 */
+	public List getSupportedMethods() {
+		return new ArrayList(methodProcessors.keySet());
+	}
+
+	private class ShutdownUnregistrationBlockListener implements
+			RegistrationStateChangeListener {
+		public List collectedNewStates = new LinkedList();
+
+		/**
+		 * The method would simply register all received events so that they
+		 * could be available for later inspection by the unit tests. In the
+		 * case where a registraiton event notifying us of a completed
+		 * registration is seen, the method would call notifyAll().
+		 * 
+		 * @param evt
+		 *            ProviderStatusChangeEvent the event describing the status
+		 *            change.
+		 */
+		public void registrationStateChanged(RegistrationStateChangeEvent evt) {
+			logger.debug("Received a RegistrationStateChangeEvent: " + evt);
+
+			collectedNewStates.add(evt.getNewState());
+
+			if (evt.getNewState().equals(RegistrationState.UNREGISTERED)) {
+				logger
+						.debug("We're unregistered and will notify those who wait");
+				synchronized (this) {
+					notifyAll();
+				}
+			}
+		}
+
+		/**
+		 * Blocks until an event notifying us of the awaited state change is
+		 * received or until waitFor miliseconds pass (whichever happens first).
+		 * 
+		 * @param waitFor
+		 *            the number of miliseconds that we should be waiting for an
+		 *            event before simply bailing out.
+		 */
+		public void waitForEvent(long waitFor) {
+			logger.trace("Waiting for a "
+					+ "RegistrationStateChangeEvent.UNREGISTERED");
+
+			synchronized (this) {
+				if (collectedNewStates.contains(RegistrationState.UNREGISTERED)) {
+					logger.trace("Event already received. "
+							+ collectedNewStates);
+					return;
+				}
+
+				try {
+					wait(waitFor);
+
+					if (collectedNewStates.size() > 0)
+						logger
+								.trace("Received a RegistrationStateChangeEvent.");
+					else
+						logger
+								.trace("No RegistrationStateChangeEvent received for "
+										+ waitFor + "ms.");
+
+				} catch (InterruptedException ex) {
+					logger.debug("Interrupted while waiting for a "
+							+ "RegistrationStateChangeEvent", ex);
+				}
+			}
+		}
+	}
+
+	/**
+	 * Returns the sip protocol icon.
+	 * 
+	 * @return the sip protocol icon
+	 */
+	public ProtocolIcon getProtocolIcon() {
+		return protocolIcon;
+	}
+
+	/**
+	 * Returns the current instance of <tt>SipStatusEnum</tt>.
+	 * 
+	 * @return the current instance of <tt>SipStatusEnum</tt>.
+	 */
+	SipStatusEnum getSipStatusEnum() {
+		return sipStatusEnum;
+	}
+
+	/**
+	 * Returns the current instance of <tt>SipRegistrarConnection</tt>.
+	 * 
+	 * @return SipRegistrarConnection
+	 */
+	SipRegistrarConnection getRegistrarConnection() {
+		return sipRegistrarConnection;
+	}
 }
Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/SipRegistrarConnection.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/SipRegistrarConnection.java	(revision 4251)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/impl/protocol/sip/SipRegistrarConnection.java	(revision 4319)
@@ -30,8 +30,10 @@
 public class SipRegistrarConnection
         implements SipListener
 {
-    private static final Logger logger =
-        Logger.getLogger(SipRegistrarConnection.class);
+	//FIXME logger use temporarily turned off
+//    private static final Logger logger =
+//        Logger.getLogger(SipRegistrarConnection.class);
+	DummyLogger logger = new DummyLogger();
 
     /**
      * A reference to the sip provider that created us.

Property changes on: D:\Users\D\Documents\GSoC 2008\workspace\msrpbranch\src\net\java\sip\communicator\impl\protocol\sip
___________________________________________________________________
Added: svn:ignore
   + *.swo
.swp


Index: D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/util/DummyLogger.java
===================================================================
--- D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/util/DummyLogger.java	(revision 0)
+++ D:/Users/D/Documents/GSoC 2008/workspace/msrpbranch/src/net/java/sip/communicator/util/DummyLogger.java	(revision 4319)
@@ -0,0 +1,70 @@
+/**
+ * 
+ */
+package net.java.sip.communicator.util;
+
+import java.text.ParseException;
+
+import javax.sip.ObjectInUseException;
+import javax.sip.PeerUnavailableException;
+import javax.sip.TransportNotSupportedException;
+
+/**
+ * Class used to disable the logger in one class for better output readability.
+ * 
+ * In order to use this, comment the logger line on the class and substitute it
+ * by a instance of this class.
+ * 
+ * This class imlpements all of the methods of the logger but logs nothing.
+ * 
+ * @author João André Pereira Antunes
+ * 
+ */
+public class DummyLogger {
+
+	public void trace(String string) {
+		//   Auto-generated method stub
+		
+	}
+
+	public void debug(String string) {
+		//   Auto-generated method stub
+		
+	}
+
+	public void error(String string) {
+		//   Auto-generated method stub
+		
+	}
+
+	public void warn(String string) {
+		//   Auto-generated method stub
+		
+	}
+
+	public void error(String string, Exception ex) {
+		//   Auto-generated method stub
+		
+	}
+
+	public void fatal(String string, Exception ex) {
+		//   Auto-generated method stub
+		
+	}
+
+	public void info(String string, Exception ex) {
+		//   Auto-generated method stub
+		
+	}
+
+	public void debug(String string, Exception ex) {
+		//   Auto-generated method stub
+		
+	}
+
+	public void info(String string) {
+		// Auto-generated method stub
+		
+	}
+
+}

Property changes on: D:\Users\D\Documents\GSoC 2008\workspace\msrpbranch\src\net\java\sip\communicator
___________________________________________________________________
Added: svn:ignore
   + *.swp



Property changes on: D:\Users\D\Documents\GSoC 2008\workspace\msrpbranch\src\net\java\sip
___________________________________________________________________
Added: svn:ignore
   + *.swp
*.swo



Property changes on: D:\Users\D\Documents\GSoC 2008\workspace\msrpbranch\src\net\java
___________________________________________________________________
Added: svn:ignore
   + *.swp


