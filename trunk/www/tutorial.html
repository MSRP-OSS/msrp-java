<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="LibreOffice 3.5  (Windows)">
	<META NAME="CREATED" CONTENT="20120710;8305183">
	<META NAME="CHANGED" CONTENT="20120810;11231446">
	<STYLE TYPE="text/css">
	<!--
		H2.cjk { font-family: "SimSun" }
		H2.ctl { font-family: "Mangal" }
		PRE.cjk { font-family: "NSimSun", monospace }
		CODE.cjk { font-family: "NSimSun", monospace }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-GB" DIR="LTR">
<H1>MSRP Library tutorial</H1>
<P>Here a brief introduction into the MSRP protocol and how you can
use this Java library to incorporate that protocol into your own
programs.</P>
<P>MSRP (or <A HREF="http://en.wikipedia.org/wiki/Message_Session_Relay_Protocol"><B>M</B>essage
<B>S</B>ession <B>R</B>elay <B>P</B>rotocol</A>) is an <A HREF="http://en.wikipedia.org/wiki/Instant_messaging">instant
messaging</A> or <A HREF="http://en.wikipedia.org/wiki/Chat">chat</A>
protocol, defined by the IETF in <A HREF="http://tools.ietf.org/html/rfc4975">RFC4975</A>.
Basically, (instant-) messages are sent to and from MSRP peers, using
SEND and REPORT requests. These messages are sent over an MSRP
session. One or more MSRP sessions can share a TCP/IP-link from one
node [AKA peer] to another (this can be achieved by any transport
protocol, provided it is connection-oriented and reliable, in the
sense of not changing the content. MSRP can be used with protocols
that provide no assurance on data delivery,as MSRP has its own
mechanisms to ensure that the data has been delivered. Here, only
TCP/IP is used).</P>
<P>The protocol is text based, much like HTTP and SIP. Using chunking
and <A HREF="http://tools.ietf.org/html/rfc2045">MIME</A>-conforming
message content (payload), thus, MSRP messages can transfer any
content of any size, supporting -for instance- file transfer. 
</P>
<H2 CLASS="western">Establishing a session</H2>
<P>MSRP assumes that some other rendezvous method will be used to
negotiate the establishment of a new MSRP session between peers. In
the RFC, the SIP protocol with its SDP <A HREF="http://tools.ietf.org/html/rfc3264">offer-answer</A>
model is used as an example.</P>
<P>This negotiation will lead to MSRP URI's, defining the endpoints
of the session. Such a URI contains a <I>scheme</I>, <I>authority</I>
(domain, port), <I>session identifier</I>, <I>transport</I>- and
other parameters.</P>
<P>You can now use the library to establish a session.</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">import java.net.InetAddress;
import javax.net.msrp.Session;
import java.net.URI;

InetAddress myAddress = InetAddress.getByName(&quot;myHostnameThatDoesMsrp&quot;);
Session activeSession = Session.create(false, false, myAddress)
URI myMsrpUri = activeSession.getURI();</PRE><P>
You have a session now with a local MSRP URI, which has to be
transmitted to the other peer through a rendezvous mechanism. This
session is an <EM>active</EM> session. It means that as soon as you
feed it the target URI, which should be transmitted to you using the
rendezvous protocol, a connection will be established (if not already
present, as MSRP allows connection re-utilization), and a first
request is immediately sent (to bound the session):</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">import java.util.ArrayList;

ArrayList&lt;URI&gt; toList = new ArrayList&lt;URI&gt;();
URI targetURI = new URI('TheNegotiatedTargetNodeMsrpUri');
toList.add(targetURI);
activeSession.addToPath(toList);</PRE><P>
The target can be a list of URI's to support <A HREF="http://tools.ietf.org/html/rfc4976">relaying</A>
of MSRP. There is no explicit support for relaying (yet) in the
library, but using the library; one could build an MSRP proxy.</P>
<P>At the other end, there is a passive session, one that knows what
node will contact it. A network socket is put in place to listen for
the connect-request.</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">URI hisMsrpUri = &lt;MSRP URI negotiated with active node...&gt;;
Session passiveSession = Session.create(false, false, hisMsrpUri, myAddress);</PRE><P>
The booleans <CODE CLASS="western">isSecure</CODE> and <CODE CLASS="western">isRelay</CODE>
are not implemented <A HREF="http://java.net/jira/browse/MSRP-44" TARGET="_blank">yet</A>.</P>
<H2 CLASS="western">Sending and receiving messages</H2>
<P>Using a session, one is now able to send and receive messages
using MSRP. Sending is easy, using the <CODE CLASS="western">sendMessage()</CODE>
methods:</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">import javax.net.msrp.Message;

Message sendMsg = activeSession.sendMessage(&quot;text/plain&quot;, &quot;Hello world\n&quot;.getBytes());</PRE><P>
The message will be sent as soon as a connection is established.</P>
<P>Receiving a message is somewhat more involved and requires the
creation of a <CODE CLASS="western">SessionListener</CODE>. This
listener will be triggered when messages are received, or status
updates are relevant. The first method to be called on receiving a
message is <CODE CLASS="western">acceptHook()</CODE>. This tells your
application that an incoming message has been received. Two things
should be done here: A <CODE CLASS="western">DataContainer</CODE>
should be attached to the message-object to be able to store any
content, and the application should decide whether you want this
message in the first place. If so, one should return <CODE CLASS="western">true</CODE>,
otherwise return <CODE CLASS="western">false</CODE>. In that case, an
error-response is automatically returned.</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">import javax.net.msrp.SessionListener;
import javax.net.msrp.IncomingMessage;
import javax.net.msrp.MemoryDataContainer;

public class MyListener implements SessionListener {
  public boolean acceptHook(Session session, IncomingMessage message) {
    MemoryDataContainer mdc = new MemoryDataContainer((int) message.getSize());
    message.setDataContainer(mdc);
    return true;
  }
}</PRE><P>
When accepted, the <CODE CLASS="western">receivedMessage()</CODE>
callback is triggered, containing the entire message and content.</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">  public void receivedMessage(Session session, IncomingMessage message) {
    System.out.print(message.getContent());
  }</PRE><P>
The above code would make sense to any message that had text-content.
The above call also unwraps any &quot;<CODE CLASS="western">message/cpim</CODE>&quot;
content that might have been sent.</P>
<H2 CLASS="western">Reports</H2>
<P>In the same listener interface, trigger <CODE CLASS="western">receivedReport()</CODE>
is defined to handle any received reports as a result of
send-actions:</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">import javax.net.msrp.ResponseCode;
...

  public void receivedReport(Session session, Transaction report) {
    int rc = report.getStatusHeader().getStatusCode();
    if (rc == ResponseCode.RC200)
      System.out.println(&quot;Success report&quot;);
    else
      System.out.println(&quot;Failure report: &quot; + ResponseCode.toString(rc));
  }</PRE><P>
If you want to more thoroughly control the reporting mechanism,
implement the abstract class <CODE CLASS="western">ReportMechanism</CODE>
and install it in the session:</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">  import javax.net.mypackage.MyReportMechanism;

  MyReportMechanism mrm = new MyReportMechanism(&lt;whatever&gt;);
  mySession.setReportMechanism(mrm);</PRE><P>
Refer to <CODE CLASS="western">Javadoc</CODE> for more details on how
this should work.</P>
<H2 CLASS="western">Wrapping messages</H2>
<P>The library also supports a message-wrapping mechanism. By
default, a wrapping mechanism for <CODE CLASS="western">message/CPIM</CODE>
is installed. Thus <CODE CLASS="western">message.getContent();</CODE>
will retrieve the wrapped content of the message, whereas
<CODE CLASS="western">message.getRawContent();</CODE> will retrieve
the complete content, including the wrapping.</P>
<P>Likewise, there is a</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">Session.sendWrappedMessage(&lt;wrapType&gt;, &lt;from&gt;, &lt;to&gt;, &lt;contentType&gt;, &lt;content&gt;);</PRE><P>
that will activate the <CODE CLASS="western">wrapType</CODE> wrapper
mechanism for wrapping the given content in a message to
send.<BR>Currently, the <CODE CLASS="western">wrapType</CODE>
<CODE CLASS="western">message/cpim</CODE> is supported.</P>
<P>Rolling your own wrapper mechanism and installing can be done with</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">javax.net.msrp.wrap.Wrap.getInstance().registerWrapper(&lt;contentType, &lt;wrapImplementor&gt;);</PRE><P>
Refer to the source code for more details.</P>
<H2 CLASS="western">Nickname support</H2>
<P>Support for the <CODE CLASS="western">NICKNAME</CODE> request as
specified in <A HREF="http://tools.ietf.org/html/draft-ietf-simple-chat-15">draft-ietf-simple-chat</A>
is also built in. See:</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">Session.requestNickname();<BR>SessionListener.receivedNickResult();</PRE><P>
and</P>
<PRE CLASS="western">SessionListener.receivedNickname();
Session.sendNickResult();
</PRE>
<H1>Getting started</H1>
<P>Access to sources and documentation can be found here in the
repository of the MSRP project. Build versions are stored in the
Maven <A HREF="http://search.maven.org/">central repository</A> and
can be included in any Maven build by specifying the dependency in a
<CODE CLASS="western">pom.xml</CODE>. Check the website to find the
latest version or search for &ldquo;msrp&rdquo; on the central
repository site:</P>
<PRE CLASS="western" STYLE="margin-left: 1cm">...
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;artifactId&gt;<STRONG>msrp</STRONG>&lt;/artifactId&gt;
    &lt;groupId&gt;<STRONG>net.java.msrp</STRONG>&lt;/groupId&gt;
    &lt;version&gt;<STRONG>1.0.1.BETA</STRONG>&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
...</PRE>
</BODY>
</HTML>